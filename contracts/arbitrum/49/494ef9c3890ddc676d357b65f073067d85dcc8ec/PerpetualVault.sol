// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.4;
pragma abicoder v2;

import "./IERC20.sol";
import "./SafeERC20.sol";
import "./Ownable2StepUpgradeable.sol";
import "./ReentrancyGuardUpgradeable.sol";
import "./IPersonalVault.sol";
import "./IManager.sol";
import "./IDataStore.sol";
import "./IVault.sol";
import "./IReader.sol";
import "./IExchangeRouter.sol";
import "./IGmxUtils.sol";

import "./console.sol";

/**
 * @notice
 *  need to restrict the vault to have only 1 open position at the same time, if not, difficult to manage positions because of async operations
 */
contract PerpetualVault is Initializable, ReentrancyGuardUpgradeable, Ownable2StepUpgradeable {
  using SafeERC20 for IERC20;

  struct PositionRequestQueue {
    bytes32 requestKey;                 //  requestKey generated by PositionRouter contract of GMX
    address tokenIn;
    address indexToken;
    bool isLong;
  }

  struct Action {
    bytes4 selector;
    bytes data;
  }

  string public name;
  IManager public manager;
  bytes32 private _referralCode;

  // Vault variables
  uint256 public constant PRECISION = 1e30;
  uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
  bytes4 constant INCREASE_ACTION = bytes4(
    keccak256("_createIncreasePosition(address,uint256,uint256,uint256,bool)")
  );
  bytes4 constant WITHDRAW_ACTION = bytes4(
    keccak256("_withdraw(address,uint256,bool)")
  );

  uint256 public totalShares;
  mapping (address => uint256) public shares;
  mapping (address => uint256) public initialDeposit;

  address public market;
  address public indexToken;
  IERC20 public collateralToken;
  IExchangeRouter public gExchangeRouter;
  IReader public gReader;
  IGmxUtils public gmxUtils;
  address public gDataStore;
  address public gReferralStorage;
  address public gOrderVault;
  IVault public gVault;              // gmx v1 contract in order to reference price data
  address public keeper;
  address public _strategy;
  bool public beenLong;
  bytes32 public curPositionKey;     //  current open positionKey
  uint256 public orderIndexCounter;   // sl/tp order index counter
  uint256 public minFund;             // 30 decimals
  uint256 public minCollateralUsd;             // 30 decimals
  bool public closed;
  uint256 public minEth;
  uint256 public governanceFee;
  //  if balance is not enough when withdrawing, `withdraw` function create position.
  //   so withdrawing action can't be done in one transaction. 
  //   register withdraw amount and address to this variable to reference in the callback function
  //   of execute position action called by GMX keeper 
  PositionRequestQueue public queue;
  
  Action nextAction;
  bytes sltp;
  bool _isLock;
  uint256 _slippage;
  uint256 _leverage;
  uint256 _gasBufferFactor;
  bytes32 slKey;
  bytes32 tpKey;

  uint256 public callbackGasLimit;

  event GmxPositionCallbackCalled(
    bytes32 requestKey,
    bool isIncrease
  );

  modifier onlyVault() {
    uint256 vaultId = IPersonalVault(msg.sender).vaultId();
    require(manager.vaultMap(vaultId) == msg.sender, "invalid caller");
    _;
  }

  modifier onlyKeeper() {
    require(msg.sender == keeper || msg.sender == address(manager), "!keeper");
    _;
  }

  // we will lock the contract from the moment we create position to the moment we get the callback from GMX keeper
  modifier lock() {
    require(_isLock == false, "locked");
    _;
  }

  /**
   * @notice
   *  `collateralToken` can be ETH, WETH, BTC, LINK, UNI, USDC, USDT, DAI, FRAX.
   *  if we want another token, need to use external DEX to swap.
   * @param _keeper keeper address
   */
  function initialize(
    string memory _name,
    address _market,
    address _collateralToken,
    address _manager,
    address _keeper,
    address _gmxUtils,
    bytes32 _refCode
  ) external initializer {
    __Ownable2Step_init();
    name = _name;
    require(_market != address(0), "zero address");
    require(_collateralToken != address(0), "zero address");
    require(_gmxUtils != address(0), "zero address");
    market = _market;
    collateralToken = IERC20(_collateralToken);
    gExchangeRouter = IExchangeRouter(0x7C68C7866A64FA2160F78EEaE12217FFbf871fa8);
    gReader = IReader(0xf60becbba223EEA9495Da3f606753867eC10d139);
    gDataStore = address(0xFD70de6b91282D8017aA4E741e9Ae325CAb992d8);
    gOrderVault = address(0x31eF83a530Fde1B38EE9A18093A333D8Bbbc40D5);
    gmxUtils = IGmxUtils(_gmxUtils);
    gReferralStorage = address(0xe6fab3F0c7199b0d34d7FbE83394fc0e0D06e99d);
    gVault = IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);
    MarketProps memory marketInfo = gReader.getMarket(gDataStore, market);
    indexToken = marketInfo.indexToken;
    keeper = _keeper;
    _referralCode = _refCode;
    governanceFee = 500;  // 5%
    _slippage = 30;   // 0.3%
    _leverage = 20_000;
    _gasBufferFactor = 12_000;
    minCollateralUsd = 10 * PRECISION;
    minEth = 0.002 ether;
    callbackGasLimit = 2_000_000;
    
    require(_manager != address(0), "zero address");
    manager = IManager(_manager);

    //  approve gmx router address
    collateralToken.safeApprove(address(0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6), type(uint256).max);
  }

  //  need payable to receive ETH when opening position
  receive() external payable {}

  /**
   * @notice
   *  deposit hypervisor token together with hedge token
   * @param amount amount of hypervisor token
   */
  function deposit(uint256 amount) external onlyVault nonReentrant lock {
    require(amount > 0, "zero amount");
    collateralToken.safeTransferFrom(msg.sender, address(this), amount);
    _issueShares(msg.sender, amount, true);
  }

  /**
   * @notice
   *  withdraw hypervisor token together with hedge token
   *  if the amount of hedge token, corresponding to hypervisor amount to withdraw, is insufficient, 
   *   create a position request to withdraw hedge token from gmx position and real withdraw action is
   *    done by `gmxPositionCallback` function in the following block.
   * @param _shares share amount of hedge token to withdraw
   */
  function withdraw(address recipient, uint256 _shares) public onlyVault nonReentrant lock returns (bool) {
    require(address(this).balance > minEth, "low than minium eth balance");
    require(recipient != address(0), "zero address");
    require(_shares != 0, "zero amount");
    require(_shares <= shares[msg.sender], "exceed due");
    require(nextAction.selector != WITHDRAW_ACTION, "withdrawal is in progress");
    return _withdraw(msg.sender, recipient, _shares, false);
  }

  /**
   * 
   * @param isOpen if true, open a position, if false, close a current position
   * @param isLong if true, open a long position, if false, open a short position
   * @param sl stop loss value. its decimals is 30
   * @param tp take profit value. its decimals is 30
   */
  function run(bool isOpen, bool isLong, uint256 sl, uint256 tp) external lock onlyKeeper {
    require(address(this).balance > minEth, "low than minium eth balance");
    uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(gDataStore, curPositionKey);

    if (isOpen) {
      closed = false;
      if (sizeInUsd == 0) {
        require(_isFundIdle() == true, "no enough balance to open position");
        sltp = abi.encode(sl, tp);
        _createIncreasePosition(0, 0, isLong);
      } else {
        if (beenLong == isLong) {
          _cancelPendingOrders();
          _createDecreaseOrder(sl, tp);
          require(_isFundIdle() == true, "no enough balance to open position");
          _createIncreasePosition(0, 0, isLong);
        } else {
          sltp = abi.encode(sl, tp);
          nextAction.selector = INCREASE_ACTION;
          nextAction.data = abi.encode(uint256(0), uint256(0), isLong);
          _createDecreasePosition(0, 0, beenLong);
        }
      }
    } else {
      closed = true;
      if (sizeInUsd > 0) {
        _createDecreasePosition(0, 0, beenLong);
      } else {
        revert("no action needed");
      }
    }
  }

  function runNextAction() external lock onlyKeeper {
    if (nextAction.selector == INCREASE_ACTION) {
      (
        uint256 amountIn,
        uint256 sizeDelta,
        bool _isLong
      ) = abi.decode(nextAction.data, (uint256,uint256,bool));
      _createIncreasePosition(amountIn, sizeDelta, _isLong);
      delete nextAction;
    } else if (nextAction.selector == WITHDRAW_ACTION) {
      (
        address to,
        address recipient,
        uint256 _shares
      ) = abi.decode(nextAction.data, (address, address, uint256));
      _withdraw(to, recipient, _shares, true);
      delete nextAction;
    } else if (closed == false && _isFundIdle()) {
      _createIncreasePosition(0, 0, beenLong);
      // sl/tp adjustment needed because position size was changed
      (uint256 sl, uint256 tp) = _cancelPendingOrders();
      sltp = abi.encode(sl, tp);
    } else {
      revert("no next action");
    }
  }

  // /**
  //  * @notice
  //  *  this function is generally not used because GMX has a keeper and the keeper detects
  //  *   `createIncreasePosition` action of `PositionRouter` contract and triggers position execution actions.
  //  *  But GMX docs says keeper may miss orders by accident,
  //  *   in that case, needs to trigger execution manually.
  //  */
  // function triggerExecutePositionRequest(bytes32 requestKey, bool isOpen) external onlyOwner {
  //   // Manual execution is possible `minTimeDelayPublic` seconds later after position created.
  //   uint256 minTimeDelayPublic = IPositionRouter(gPositionRouter).minTimeDelayPublic();
  //   if (isOpen) {
  //     IncreasePositionRequest memory request = IPositionRouter(gPositionRouter).increasePositionRequests(requestKey);
  //     require(request.blockTime + minTimeDelayPublic <= block.timestamp, "delay");
  //     IPositionRouter(gPositionRouter).executeIncreasePosition(requestKey, payable(this));
  //   } else {
  //     DecreasePositionRequest memory request = IPositionRouter(gPositionRouter).decreasePositionRequests(requestKey);
  //     require(request.blockTime + minTimeDelayPublic <= block.timestamp, "delay");
  //     IPositionRouter(gPositionRouter).executeDecreasePosition(requestKey, payable(this));
  //   }
  //   _isLock = false;
  // }

  function afterOrderExecution(bytes32 key, Order.Props memory order) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    require(queue.requestKey == key, "invalid request callback");
    
    _isLock = false;
    uint256 sl;
    uint256 tp;
    if (order.numbers.orderType == Order.OrderType.MarketIncrease) {
      curPositionKey = keccak256(abi.encode(address(this), order.addresses.market, collateralToken, order.flags.isLong));
      beenLong = order.flags.isLong;
      _cancelPendingOrders();
      (sl, tp) = abi.decode(sltp, (uint256, uint256));
      _createDecreaseOrder(sl, tp);
      delete sltp;
    } else {
      uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(gDataStore, curPositionKey);
      (sl, tp) = _cancelPendingOrders();
      if (sizeInUsd > 0) {
        _createDecreaseOrder(sl, tp);   // create decrease orders with the updated size data
        curPositionKey = hex'';
      }
    }
    delete queue;
    emit GmxPositionCallbackCalled(key, true);
  }

  function afterOrderCancellation(bytes32 key, Order.Props memory /* order */) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    delete nextAction;
    emit GmxPositionCallbackCalled(key, false);
  }

  function afterOrderFrozen(bytes32 key, Order.Props memory order) external {}

  // /**
  //  * @notice
  //  *  this function is a callback of execute position action from GMX Position Router
  //  *  can be used for several purpose in the future
  //  */
  // function gmxPositionCallback(bytes32 requestKey, bool isExecuted, bool isIncrease) external override nonReentrant {
  //   require(msg.sender == address(gPositionRouter), "invalid caller");
  //   require(queue.requestKey == requestKey, "invalid request callback");

  //   _isLock = false;
  //   if (isExecuted) {
  //     if (isIncrease) {
  //       curPositionKey = keccak256(abi.encodePacked(
  //         address(this),
  //         queue.tokenIn,
  //         queue.indexToken,
  //         queue.isLong
  //       ));
  //       beenLong = queue.isLong;
  //       _cancelPendingOrders();
  //       if (sltp.length > 0) {
  //         (uint256 sl, uint256 tp) = abi.decode(sltp, (uint256, uint256));
  //         _createDecreaseOrder(sl, tp);
  //         delete sltp;
  //       }
  //     } else {
  //       // cancel pending order only in the case of full decrease (partial decrease may happen when withdraw function called)
  //       (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
  //       if (size == 0) {
  //         _cancelPendingOrders();
  //       }
  //     }
      
  //   } else {
  //     delete nextAction;
  //   }
    
  //   delete queue;

  //   emit GmxPositionCallbackCalled(requestKey, isExecuted, isIncrease);
  // }

  //////////////////////////////
  ////    View Functions    ////
  //////////////////////////////

  /**
   * @notice
   *  check the description of `_estimatedTotalHedgeAmount`
   */
  function totalAmount() public view returns (uint256) {
    if (curPositionKey == bytes32(0)) {
      return collateralToken.balanceOf(address(this));
    }
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(
      gDataStore,
      gReader,
      market,
      gReferralStorage,
      curPositionKey,
      manager
    );
    return collateralToken.balanceOf(address(this)) + positionData.netValueInCollateralToken;
  }

  function getPositionInfo() external view returns (address, address, uint256, uint256,uint256, uint256, bool) {
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(
      gDataStore,
      gReader,
      market,
      gReferralStorage,
      curPositionKey,
      manager
    );
    return (
      market,
      address(collateralToken),
      positionData.sizeInUsd,
      positionData.sizeInTokens,
      positionData.collateralAmount,
      positionData.netValueInCollateralToken,
      positionData.isLong
    );
  }

  function isNextAction() external view returns (bool) {
    // (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    if (_isLock == true ) {
      return false;
    } else if (nextAction.data.length > 0 || (_isFundIdle() && closed == false)) {
      return true;
    } else {
      return false;
    }
  }

  function isWithdrawing() external view returns (bool) {
    return nextAction.selector == WITHDRAW_ACTION;
  }

  function referralCode() external view returns (bytes32) {
    return _referralCode;
  }

  function isLock() external view returns (bool) {
    return _isLock;
  }

  function slippage() external view returns (uint256) {
    return _slippage;
  }

  function strategy() external view returns (address) {
    return _strategy;
  }

  function withdrawEth() public nonReentrant onlyOwner {
    payable(msg.sender).transfer(address(this).balance);
  }

  function setKeeper(address _keeper) external onlyOwner {
    require(_keeper != address(0), "zero address");
    keeper = _keeper;
  }

  function setGmxUtils(address _gmxUtils) external onlyOwner {
    require(_gmxUtils != address(0), "zero address");
    gmxUtils = IGmxUtils(_gmxUtils);
    gmxUtils.setPerpVault(address(this));
  }

  function setLock(bool locked) external onlyOwner {
    _isLock = locked;
  }

  function setSlippage(uint256 val) external onlyOwner {
    _slippage = val;
  }

  function setLeverageValue(uint256 val) external onlyOwner {
    require(val > BASIS_POINTS_DIVISOR, "low than minimum");
    _leverage = val;
  }

  function setMinFund(uint256 _minFund) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minFund >= min, "minimum");
    minFund = _minFund;
  }

  function setMinCollateralUsd(uint256 _minCollateralUsd) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minCollateralUsd > min, "minimum");
    minCollateralUsd = _minCollateralUsd;
  }

  function setMinEth(uint256 _minEth) external onlyOwner {
    require(_minEth > 0, "minimum");
    minEth = _minEth;
  }

  function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {
    require(_callbackGasLimit > 0, "zero value");
    callbackGasLimit = _callbackGasLimit;
  }
  
  //////////////////////////////
  ////  Internal Functions  ////
  //////////////////////////////

  function _issueShares(address to, uint256 amount, bool isMint) internal {
    if (isMint) {
      uint256 _shares = 0;
      if (totalShares > 0) {
        _shares = amount * totalShares / totalAmount();
      } else {
        _shares = amount;
      }

      shares[to] = shares[to] + _shares;
      totalShares = totalShares + _shares;
    } else {
      shares[to] = shares[to] - amount;
      totalShares = totalShares - amount;
    }
  }

  function _isFundIdle() internal view returns (bool) {
    uint256 balance = collateralToken.balanceOf(address(this));
    if (gmxUtils.tokenToUsdMin(address(manager), address(collateralToken), balance) > minFund) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @notice
   *  create increase position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't open position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param amountIn: the amount of tokenIn you want to deposit as collateral
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createIncreasePosition(
    uint256 amountIn,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    uint256 positionExecutionFee = 
      gmxUtils.getExecutionGasLimit(gDataStore, Order.OrderType.MarketIncrease, callbackGasLimit) * tx.gasprice;
    require(address(this).balance >= positionExecutionFee, "too low execution fee");
    gExchangeRouter.sendWnt{value: positionExecutionFee}(gOrderVault, positionExecutionFee);
    // check available amounts to open positions
    if (amountIn == 0) {
      amountIn = collateralToken.balanceOf(address(this));
    }
    gExchangeRouter.sendTokens(address(collateralToken), gOrderVault, amountIn);
    if (sizeDelta == 0) {
      sizeDelta = gmxUtils.tokenToUsdMin(address(manager), address(collateralToken), amountIn) * _leverage / BASIS_POINTS_DIVISOR;
    }
    // _checkPool(_isLong, indexToken, _tokenIn, sizeDelta);    //  check later
    uint256 acceptablePrice = _isLong ? 
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR + _slippage) / BASIS_POINTS_DIVISOR :
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR - _slippage) / BASIS_POINTS_DIVISOR;
    address[] memory swapPath;
    CreateOrderParamsAddresses memory paramsAddresses = CreateOrderParamsAddresses({
      receiver: address(this),
      callbackContract: address(gmxUtils),
      uiFeeReceiver: address(0),      // this is a third party ui fee receiver.
      market: market,
      initialCollateralToken: address(collateralToken),
      swapPath: swapPath
    });
    CreateOrderParamsNumbers memory paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: sizeDelta,
      initialCollateralDeltaAmount: 0,      // not clear, but default is zero
      triggerPrice: 0,      // this param is an opening trigger price. not closing trigger price
      acceptablePrice: acceptablePrice,
      executionFee: positionExecutionFee,
      callbackGasLimit: callbackGasLimit,
      minOutputAmount: 0      // this param is used when swapping. is not used in opening position even though swap involved.
    });
    CreateOrderParams memory params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: Order.OrderType.MarketIncrease,   // OrderType, 2 is marketIncrease(long), 4 is marketDecrease(short)
      decreasePositionSwapType: Order.DecreasePositionSwapType.NoSwap,
      isLong: _isLong,
      shouldUnwrapNativeToken: false,
      referralCode: _referralCode
    });
    bytes32 requestKey = gExchangeRouter.createOrder(params);

    // (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    // if (size == 0) {
    //   // did balance check basically in the prior function but need to do again here 
    //   //  against the current gmx min value to avoid potential gmx side transaction failure.
    //   require(sizeDelta > vaultMinUsd(), "insufficient amount to open position");
    // }

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  /**
   * @notice
   *  create decrease position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't close position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralDelta: the amount of collateral in USD value to withdraw
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createDecreasePosition(
    uint256 collateralDelta,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    uint256 positionExecutionFee = 
      gmxUtils.getExecutionGasLimit(gDataStore, Order.OrderType.MarketDecrease, callbackGasLimit) * tx.gasprice;
    require(address(this).balance >= positionExecutionFee, "too low execution fee");

    uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(gDataStore, curPositionKey);
    if (
      sizeDelta == 0 ||
      sizeInUsd - sizeDelta < minCollateralUsd     // suppose we don't do above 1.1x leverage. so size is nearly the same as collateral amount
    ) {
      sizeDelta = sizeInUsd;
    }

    // _checkPool(_isLong, market, sizeDelta);
    
    uint256 acceptablePrice = _isLong ?
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR - _slippage) / BASIS_POINTS_DIVISOR :
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR + _slippage) / BASIS_POINTS_DIVISOR;

    address[] memory swapPath;
    CreateOrderParamsAddresses memory paramsAddresses = CreateOrderParamsAddresses({
      receiver: address(this),
      callbackContract: address(gmxUtils),
      uiFeeReceiver: address(0),      // not clear. but default is zero
      market: market,
      initialCollateralToken: address(collateralToken),
      swapPath: swapPath
    });
    CreateOrderParamsNumbers memory paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: sizeDelta,
      initialCollateralDeltaAmount: collateralDelta,
      triggerPrice: 0,      // this param is an opening trigger price. not closing trigger price
      acceptablePrice: acceptablePrice,
      executionFee: positionExecutionFee,
      callbackGasLimit: callbackGasLimit,
      minOutputAmount: 0      // this param is used when swapping. is not used in opening position even though swap involved.
    });
    CreateOrderParams memory params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: Order.OrderType.MarketDecrease,   // OrderType, 2 is marketIncrease(long), 4 is marketDecrease(short)
      decreasePositionSwapType: Order.DecreasePositionSwapType.SwapPnlTokenToCollateralToken,      // 1 means swap pnl(profit&loss) to collateral token
      isLong: _isLong,
      shouldUnwrapNativeToken: false,
      referralCode: _referralCode
    });
    bytes32 requestKey = gExchangeRouter.createOrder(params);

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;

  }

  function _createDecreaseOrder(uint256 sl, uint256 tp) internal {
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(gDataStore, gReader, market, gReferralStorage, curPositionKey, manager);
    uint256 acceptablePrice = beenLong ?
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR - _slippage) / BASIS_POINTS_DIVISOR :
      manager.getTokenPrice(indexToken) * (BASIS_POINTS_DIVISOR + _slippage) / BASIS_POINTS_DIVISOR;

    address[] memory swapPath;
    CreateOrderParamsAddresses memory paramsAddresses = CreateOrderParamsAddresses({
      receiver: address(this),
      callbackContract: address(0),
      uiFeeReceiver: address(0),      // not clear. but default is zero
      market: market,
      initialCollateralToken: address(collateralToken),
      swapPath: swapPath
    });
    uint256 positionExecutionFee = 
      gmxUtils.getExecutionGasLimit(gDataStore, Order.OrderType.LimitDecrease, 0) * tx.gasprice;
    CreateOrderParamsNumbers memory paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: positionData.sizeInUsd,
      initialCollateralDeltaAmount: positionData.collateralAmount,
      triggerPrice: sl,      // this param is an opening trigger price. not closing trigger price
      acceptablePrice: acceptablePrice,
      executionFee: positionExecutionFee,
      callbackGasLimit: 0,
      minOutputAmount: 0      // this param is used when swapping. is not used in opening position even though swap involved.
    });
    CreateOrderParams memory params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: Order.OrderType.LimitDecrease,
      decreasePositionSwapType: Order.DecreasePositionSwapType.NoSwap,
      isLong: beenLong,
      shouldUnwrapNativeToken: false,
      referralCode: _referralCode
    });
    slKey = gExchangeRouter.createOrder(params);

    positionExecutionFee = 
      gmxUtils.getExecutionGasLimit(gDataStore, Order.OrderType.StopLossDecrease, 0) * tx.gasprice;
    paramsNumber = CreateOrderParamsNumbers({
      sizeDeltaUsd: positionData.sizeInUsd,
      initialCollateralDeltaAmount: positionData.collateralAmount,
      triggerPrice: tp,      // this param is an opening trigger price. not closing trigger price
      acceptablePrice: acceptablePrice,
      executionFee: positionExecutionFee,
      callbackGasLimit: 0,
      minOutputAmount: 0      // this param is used when swapping. is not used in opening position even though swap involved.
    });

    params = CreateOrderParams({
      addresses: paramsAddresses,
      numbers: paramsNumber,
      orderType: Order.OrderType.StopLossDecrease,
      decreasePositionSwapType: Order.DecreasePositionSwapType.NoSwap,
      isLong: beenLong,
      shouldUnwrapNativeToken: false,
      referralCode: _referralCode
    });
    tpKey = gExchangeRouter.createOrder(params);

    // // gmx orderBook contract requires that execution fee be strictly greater than instead of gte
    // require(address(this).balance >= orderExecutionFee + 1, "too low execution fee");
    // IOrderBook(gOrderBook).createDecreaseOrder{value: orderExecutionFee + 1}(
    //   indexToken,
    //   _sizeDelta,
    //   _tokenIn,
    //   0,
    //   beenLong,
    //   _triggerPrice,
    //   _triggerAboveThreshold
    // );
  }

  // cancel all orders when switching positions
  function _cancelPendingOrders() internal returns (uint256 sl, uint256 tp) {
    Order.Props[] memory orders = gReader.getAccountOrders(gDataStore, address(this), 0, 1);
    if (orders[0].numbers.orderType == Order.OrderType.LimitDecrease) {
      sl = orders[1].numbers.triggerPrice;
      tp = orders[0].numbers.triggerPrice;
    } else {
      sl = orders[0].numbers.triggerPrice;
      tp = orders[1].numbers.triggerPrice;
    }
    bytes32 accountOrderListKey = keccak256(abi.encode(keccak256(abi.encode("ACCOUNT_ORDER_LIST")), address(this)));
    bytes32[] memory orderKeys = IDataStore(gDataStore).getBytes32ValuesAt(accountOrderListKey, 0, 10);
    for (uint8 i = 0; i < orderKeys.length; ) {
      gExchangeRouter.cancelOrder(orderKeys[i]);
      unchecked{
        i = i + 1;
      }
    }
    return (sl, tp);
  }

  function _withdraw(address to, address recipient, uint256 _shares, bool forced) internal returns (bool) {
    // get amount to withdraw from the estimated total hedgeAmount(balance + GMX liquidity)
    uint256 amount = totalAmount() * _shares / totalShares;
    uint256 balance = collateralToken.balanceOf(address(this));
    if (forced || balance >= amount ) {
      uint256 fee = (amount - initialDeposit[to]) * governanceFee / BASIS_POINTS_DIVISOR;
      collateralToken.safeTransfer(manager.treasury(), fee);
      collateralToken.safeTransfer(recipient, amount - fee);
      balance = balance - amount;
      _issueShares(to, _shares, false);
      return true;
    }

    // if we don't have enough balance, need to withdraw from GMX
    //  when decreasing position, we can't indicate amount of collateral token to withdraw using collateralDelta
    //   because `swapFee` and `closeFee` would be deducted from `amountOut`. it may need to multiply 1.01. should check exact multiplier value via testing
    uint256 want = amount - balance;
          
    // (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(gDataStore, curPositionKey);

    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(
      gDataStore,
      gReader,
      market,
      gReferralStorage,
      curPositionKey,
      manager
    );
    uint256 sizeDelta;
    uint256 collateralDelta;
    if (want > positionData.netValueInCollateralToken) {
      sizeDelta = sizeInUsd;
      collateralDelta = gmxUtils.tokenToUsdMin(address(manager), address(collateralToken), positionData.netValueInCollateralToken);      // can be set as 0
    } else {
      //  may need to consider fee deduction
      sizeDelta = want * sizeInUsd / positionData.netValueInCollateralToken;   //  want * size / netValue
      collateralDelta = gmxUtils.tokenToUsdMin(address(manager), address(collateralToken), want);          // can be set as 0
    }

    nextAction.selector = WITHDRAW_ACTION;
    nextAction.data = abi.encode(to, recipient, _shares);
    _createDecreasePosition(collateralDelta, sizeDelta, beenLong);
    return false;
  }

  /**
   * @notice
   *  check available liquidity before create positions
   */
  // function _checkPool(bool _isLong, address _indexToken, address _tokenIn, uint256 sizeDelta) internal view {
  //   uint256 maxReservedUsd = getMaxReservedUsd(market, isLong);
  //   uint256 availableTokens = gVault.poolAmounts(_tokenIn) - gVault.reservedAmounts(_tokenIn);
  //   require(sizeDelta < gVault.tokenToUsdMin(_tokenIn, availableTokens), "max longs / shorts exceeded");
    
  //   if (_isLong) {
  //     uint256 maxGlobalLongSize = IPositionRouter(gPositionRouter).maxGlobalLongSizes(_indexToken);
  //     if (maxGlobalLongSize != 0) {
  //       require(
  //         gVault.guaranteedUsd(_indexToken) + sizeDelta < maxGlobalLongSize,
  //         "max longs exceeded"
  //       );
  //     }
  //   } else {
  //     uint256 maxGlobalShortSize = IPositionRouter(gPositionRouter).maxGlobalShortSizes(_indexToken);
  //     if (maxGlobalShortSize != 0) {
  //       require(
  //         gVault.globalShortSizes(_indexToken) + sizeDelta < maxGlobalShortSize,
  //         "max shorts exceeded"
  //       );
  //     }
  //   }
  // }
}

