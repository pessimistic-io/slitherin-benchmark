/**

 Telegram - https://t.me/mindaimusic
 Twitter -  https://twitter.com/MindAIMusic
 Website -  https://mindaimusic.com/

MindAI is an innovative crypto project that revolutionizes the music industry by 
leveraging the power of artificial intelligence (AI) and blockchain technology. 
At its core, MindAI provides a user-friendly platform that enables users to generate AI-generated music, 
create music NFTs (Non-Fungible Tokens), and explore a diverse range of musical creations.

With MindAI's platform, users have the freedom to experiment and express their artistic visions, 
harnessing the capabilities of AI algorithms to compose unique melodies, harmonies, and rhythms. 
The resulting music can then be minted as NFTs, granting them provable ownership and authenticity on the blockchain.

One of the remarkable features of MindAI is the ability for users to listen to the music generated by AI, 
allowing them to appreciate the creativity and diversity of the AI-driven compositions. 
By enabling direct engagement with the music, MindAI creates an immersive and interactive experience for music enthusiasts.

Moreover, MindAI ensures that creators are duly rewarded for their contributions. 
Through the integration of blockchain technology, artists receive royalties whenever their music is played, 
streamed, or used in various commercial applications. This incentivizes creators and encourages 
them to continue producing exceptional music on the platform.

MindAI also provides a comprehensive set of music AI tools, granting users access to a wide array 
of resources and technologies. These tools assist creators in refining their compositions, enhancing 
the quality of their music, and exploring new horizons in music production.

To further engage its community, MindAI offers a token economy where users can stake their tokens and 
earn rewards. By staking their tokens, participants contribute to the platform's security and 
stability while receiving incentives for their support.

In summary, MindAI pioneers the fusion of AI, music, and blockchain, enabling users to generate AI music, 
create music NFTs, listen to AI-generated music, earn royalties, access music AI tools, and stake tokens for rewards. 
It empowers creators, revolutionizes the way we experience music, and shapes the future of the industry.

*/

// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.7.6;

interface ERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
    function name() external view returns (string memory);
    function getOwner() external view returns (address);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address _owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

abstract contract Ownable {
    address internal owner;
    constructor(address _owner) {
        owner = _owner;
    }
    modifier onlyOwner() {
        require(isOwner(msg.sender), "!OWNER"); _;
    }
    function isOwner(address account) public view returns (bool) {
        return account == owner;
    }
    function renounceOwnership() public onlyOwner {
        owner = address(0);
        emit OwnershipTransferred(address(0));
    }  
    event OwnershipTransferred(address owner);
}

interface IDEXFactory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IDEXRouter {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

contract MindAI is ERC20, Ownable {
    address routerAdress = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;
    address DEAD = 0x000000000000000000000000000000000000dEaD;

    string constant _name = "MindAI Music";
    string constant _symbol = "MAIM";
    uint8 constant _decimals = 18;

    uint256 public _totalSupply = 100_000_000 * (10 ** _decimals);
    uint256 public _maxWalletAmount = (_totalSupply * 10) / 100;
    uint256 public _maxTxAmount = (_totalSupply * 100) / (100); //100%

    mapping (address => uint256) _balances;
    mapping (address => mapping (address => uint256)) _allowances;

    mapping (address => bool) isFeeExempt;
    mapping (address => bool) isTxLimitExempt;

    uint256 CreatorsFee = 1; 
    uint256 StakingFee = 1;
    uint256 totalFee = CreatorsFee + StakingFee;
    uint256 feeDenominator = 100;

    address public StakingFeeReceiver = 0xac12379D88d2B55b6a92cF86D76aBfB09573C917;

    IDEXRouter public router;
    address public pair;

    bool public swapEnabled = true;
    uint256 public swapThreshold = _totalSupply / 600 * 5; // 0.3%
    bool inSwap;
    modifier swapping() { inSwap = true; _; inSwap = false; }

    constructor () Ownable(msg.sender) {
        router = IDEXRouter(routerAdress);
        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));
        _allowances[address(this)][address(router)] = type(uint256).max;

        address _owner = owner;
        isFeeExempt[0x15dB090688cBbf53A08df4F7DD2885c479882106] = true;
        isTxLimitExempt[_owner] = true;
        isTxLimitExempt[0x15dB090688cBbf53A08df4F7DD2885c479882106] = true;
        isTxLimitExempt[DEAD] = true;

        _balances[_owner] = _totalSupply;
        emit Transfer(address(0), _owner, _totalSupply);
    }

    receive() external payable { }

    function totalSupply() external view override returns (uint256) { return _totalSupply; }
    function decimals() external pure override returns (uint8) { return _decimals; }
    function symbol() external pure override returns (string memory) { return _symbol; }
    function name() external pure override returns (string memory) { return _name; }
    function getOwner() external view override returns (address) { return owner; }
    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }
    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function approveMax(address spender) external returns (bool) {
        return approve(spender, type(uint256).max);
    }

    function transfer(address recipient, uint256 amount) external override returns (bool) {
        return _transferFrom(msg.sender, recipient, amount);
    }

    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {
        if(_allowances[sender][msg.sender] != type(uint256).max){
            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;
        }

        return _transferFrom(sender, recipient, amount);
    }

    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {
        if(inSwap){ return _basicTransfer(sender, recipient, amount); }
        
        if (recipient != pair && recipient != DEAD) {
            require(isTxLimitExempt[recipient] || _balances[recipient] + amount <= _maxWalletAmount, "Transfer amount exceeds the bag size.");
        }
        
        if(shouldSwapBack()){ swapBack(); } 

        _balances[sender] = _balances[sender] - amount;

        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(sender, amount) : amount;
        _balances[recipient] = _balances[recipient] +amountReceived;

        emit Transfer(sender, recipient, amountReceived);
        return true;
    }
    
    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {
        _balances[sender] = _balances[sender] - amount;
        _balances[recipient] = _balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    function shouldTakeFee(address sender) internal view returns (bool) {
        return !isFeeExempt[sender];
    }

    function takeFee(address sender, uint256 amount) internal returns (uint256) {
        uint256 feeAmount = (amount * totalFee) / feeDenominator;
        _balances[address(this)] = _balances[address(this)] + feeAmount;
        emit Transfer(sender, address(this), feeAmount);
        return amount - feeAmount;
    }

    function shouldSwapBack() internal view returns (bool) {
        return msg.sender != pair
        && !inSwap
        && swapEnabled
        && _balances[address(this)] >= swapThreshold;
    }

    function swapBack() internal swapping {
        uint256 contractTokenBalance = swapThreshold;
        uint256 amountToLiquify = ((contractTokenBalance * CreatorsFee) /  totalFee) / 2;
        uint256 amountToSwap = contractTokenBalance - amountToLiquify;

        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = router.WETH();

        uint256 balanceBefore = address(this).balance;

        router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            amountToSwap,
            0,
            path,
            address(this),
            block.timestamp
        );
        uint256 amountETH = address(this).balance - balanceBefore;
        uint256 totalETHFee = (totalFee - CreatorsFee) / 2;
        uint256 amountETHCreators = ((amountETH * CreatorsFee) / totalETHFee) / 2;
        uint256 amountETHStaking = (amountETH * StakingFee) / totalETHFee;


        (bool StakingSuccess, /* bytes memory data */) = payable(StakingFeeReceiver).call{value: amountETHStaking, gas: 30000}("");
        require(StakingSuccess, "receiver rejected ETH transfer");

        if(amountToLiquify > 0){
            router.addLiquidityETH{value: amountETHCreators}(
                address(this),
                amountToLiquify,
                0,
                0,
                0x26B77C4c0572F39468F54Fd9494556A0a86721ab,
                block.timestamp
            );
            emit AutoLiquify(amountETHCreators, amountToLiquify);
        }
    }

    function buyTokens(uint256 amount, address to) internal swapping {
        address[] memory path = new address[](2);
        path[0] = router.WETH();
        path[1] = address(this);

        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(
            0,
            path,
            to,
            block.timestamp
        );
    }

    function clearStuckBalance() external {
        payable(StakingFeeReceiver).transfer(address(this).balance);
    }

    function setWalletLimit(uint256 amountPercent) external onlyOwner {
        _maxWalletAmount = (_totalSupply * amountPercent ) / 1000;
    }

    function setFee(uint256 _CreatorsFee, uint256 _StakingFee) external onlyOwner {
         CreatorsFee = _CreatorsFee; 
         StakingFee = _StakingFee;
         totalFee = CreatorsFee + StakingFee;
    }    
    
    event AutoLiquify(uint256 amountETH, uint256 amountBOG);
}