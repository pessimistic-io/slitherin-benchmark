pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : Staking
*/abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and make it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        // On the first call to nonReentrant, _notEntered will be true
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;

        _;

        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }
}
/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
	/**
	 * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
	 * by `operator` from `from`, this function is called.
	 *
	 * It must return its Solidity selector to confirm the token transfer.
	 * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
	 *
	 * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
	 */
	function onERC721Received(
		address operator,
		address from,
		uint256 tokenId,
		bytes calldata data
	) external returns (bytes4);
}

interface ERC20{
	function balanceOf(address account) external view returns (uint256);
	function transfer(address recipient, uint256 amount) external returns (bool);
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface ERC721{
	function safeTransferFrom(address from, address to, uint256 tokenId) external;
}

contract Staking is ReentrancyGuard {

	address owner;
	struct record { address staker; uint256 stakeTime; uint256 lastUpdateTime; uint256 accumulatedInterestToUpdateTime; uint256 amtWithdrawn; }
	mapping(uint256 => record) public informationAboutStakeScheme;
	address[] public stakedAddresses;
	mapping(address => uint256[]) public userNfts;
	uint256 public dailyInterestRate = uint256(60000);
	uint256 public minStakePeriod = (uint256(1500) * uint256(864));
	uint256 public totalWithdrawals = uint256(0);
	uint256 public unstakeClaimCoinPrice0 = uint256(750000000000000000000);
	address[] public whitelist;
	event Staked (uint256 indexed tokenId);
	event Unstaked (uint256 indexed tokenId);

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function isInside_address(address _j0, address[] memory _j1) internal pure returns (bool){
		for (uint _i = 0; _i < _j1.length; _i++){
			if (_j0 == _j1[_i]){
				return true;
			}
		}
		return false;
	}

	function minUIntPair(uint _i, uint _j) internal pure returns (uint){
		if (_i < _j){
			return _i;
		}else{
			return _j;
		}
	}	

	function onERC721Received( address, address, uint256, bytes calldata ) public pure returns (bytes4) {
		return this.onERC721Received.selector;
	}

/**
 * Function changeValueOf_minStakePeriod
 * Notes for _minStakePeriod : 1 day is represented by 86400 (seconds)
 * The function takes in 1 variable, (zero or a positive integer) _minStakePeriod. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates minStakePeriod as _minStakePeriod
*/
	function changeValueOf_minStakePeriod(uint256 _minStakePeriod) external onlyOwner {
		minStakePeriod  = _minStakePeriod;
	}

/**
 * Function changeValueOf_unstakeClaimCoinPrice0
 * Notes for _unstakeClaimCoinPrice0 : 10^18 represents 1 YachtingVerse
 * The function takes in 1 variable, (zero or a positive integer) _unstakeClaimCoinPrice0. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * updates unstakeClaimCoinPrice0 as _unstakeClaimCoinPrice0
*/
	function changeValueOf_unstakeClaimCoinPrice0(uint256 _unstakeClaimCoinPrice0) external onlyOwner {
		unstakeClaimCoinPrice0  = _unstakeClaimCoinPrice0;
	}

/**
 * Function stake
 * Daily Interest Rate : Variable dailyInterestRate
 * Minimum Stake Period : Variable minStakePeriod
 * Address Map : informationAboutStakeScheme
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that current time is less than or equals to 1710252000
 * updates informationAboutStakeScheme (Element _tokenId) as Struct comprising (the address that called this function), current time, current time, 0, 0
 * calls ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at safeTransferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as _tokenId
 * emits event Staked with inputs _tokenId
 * adds _tokenId to userNfts (Element the address that called this function)
 * creates an internal variable found
 * repeat length of stakedAddresses times with loop variable i0 :  (if (stakedAddresses with element Loop Variable i0) is equals to (the address that called this function) then (updates found as true; and then terminates the for-next loop))
 * if not found then (adds the address that called this function to stakedAddresses)
 * checks that check if (the address that called this function) is inside whitelist
*/
	function stake(uint256 _tokenId) public {
		require((block.timestamp <= uint256(1710252000)), "Date has passed");
		informationAboutStakeScheme[_tokenId]  = record (msg.sender, block.timestamp, block.timestamp, uint256(0), uint256(0));
		ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).safeTransferFrom(msg.sender, address(this), _tokenId);
		emit Staked(_tokenId);
		userNfts[msg.sender].push(_tokenId);
		bool found;
		for (uint i0 = 0; i0 < (stakedAddresses).length; i0++){
			if ((stakedAddresses[i0] == msg.sender)){
				found  = true;
				break;
			}
		}
		if (!(found)){
			stakedAddresses.push(msg.sender);
		}
		require(isInside_address(msg.sender, whitelist), "Address not on whitelist");
	}

/**
 * Function unstake
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * this function fails here
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element _tokenId
 * checks that ((current time) - (minStakePeriod)) is greater than or equals to (thisRecord with element stakeTime)
 * creates an internal variable interestToRemove with initial value (thisRecord with element accumulatedInterestToUpdateTime) + ((((minimum of current time, 1710252000) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate) * (1000000000000000000)) / (864000000))
 * checks that (ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to interestToRemove
 * if interestToRemove is strictly greater than 0 then (calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transfer function  with variable recipient as (the address that called this function), variable amount as interestToRemove)
 * updates totalWithdrawals as (totalWithdrawals) + (interestToRemove)
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * deletes item _tokenId from mapping informationAboutStakeScheme
 * calls ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at safeTransferFrom function  with variable sender as (the address of this contract), variable recipient as (the address that called this function), variable amount as _tokenId
 * emits event Unstaked with inputs _tokenId
 * creates an internal variable nfts with initial value userNfts with element the address that called this function
 * creates an internal variable nftLength with initial value length of nfts
 * repeat nftLength times with loop variable i0 :  (if (nfts with element Loop Variable i0) is equals to _tokenId then (if (Loop Variable i0) is equals to ((nftLength) - (1)) then it does nothing else otherwise (updates nfts (Element Loop Variable i0) as nfts with element (nftLength) - (1)); then removes last item from nfts; then if (length of nfts) is equals to 0 then (repeat length of stakedAddresses times with loop variable i1 :  (if (the address that called this function) is equals to (stakedAddresses with element Loop Variable i1) then (if (Loop Variable i1) is equals to ((length of stakedAddresses) - (1)) then it does nothing else otherwise (updates stakedAddresses (Element Loop Variable i1) as stakedAddresses with element (length of stakedAddresses) - (1)); then removes last item from stakedAddresses; and then terminates the for-next loop))); and then terminates the for-next loop))
 * calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as unstakeClaimCoinPrice0
*/
	function unstake(uint256 _tokenId) public nonReentrant {
		record memory thisRecord = informationAboutStakeScheme[_tokenId];
		require(((block.timestamp - minStakePeriod) >= thisRecord.stakeTime), "Insufficient stake period");
		uint256 interestToRemove = (thisRecord.accumulatedInterestToUpdateTime + (((minUIntPair(block.timestamp, uint256(1710252000)) - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(864000000)));
		require((ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).balanceOf(address(this)) >= interestToRemove), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((interestToRemove > uint256(0))){
			ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transfer(msg.sender, interestToRemove);
		}
		totalWithdrawals  = (totalWithdrawals + interestToRemove);
		require((thisRecord.staker == msg.sender), "You do not own this token");
		delete informationAboutStakeScheme[_tokenId];
		ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).safeTransferFrom(address(this), msg.sender, _tokenId);
		emit Unstaked(_tokenId);
		uint256[] storage nfts = userNfts[msg.sender];
		uint256 nftLength = (nfts).length;
		for (uint i0 = 0; i0 < nftLength; i0++){
			if ((nfts[i0] == _tokenId)){
				if ((i0 == (nftLength - uint256(1)))){
				}else{
					nfts[i0]  = nfts[(nftLength - uint256(1))];
				}
				nfts.pop();
				if (((nfts).length == uint256(0))){
					for (uint i1 = 0; i1 < (stakedAddresses).length; i1++){
						if ((msg.sender == stakedAddresses[i1])){
							if ((i1 == ((stakedAddresses).length - uint256(1)))){
							}else{
								stakedAddresses[i1]  = stakedAddresses[((stakedAddresses).length - uint256(1))];
							}
							stakedAddresses.pop();
							break;
						}
					}
				}
				break;
			}
		}
		ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transferFrom(msg.sender, address(this), unstakeClaimCoinPrice0);
	}

/**
 * Function multipleStake
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls stake with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleStake(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			stake(tokenIds[i0]);
		}
	}

/**
 * Function multipleUnstake
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * this function fails here
 * repeat length of tokenIds times with loop variable i0 :  (calls unstake with variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleUnstake(uint256[] memory tokenIds) public nonReentrant {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			unstake(tokenIds[i0]);
		}
	}

/**
 * Function unstakeAllThatIOwn
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * this function fails here
 * creates an internal variable nfts with initial value userNfts with element the address that called this function
 * repeat length of nfts times with loop variable i0 :  (calls unstake with variable _tokenId as (nfts with element (Loop Variable i0) - (1)))
*/
	function unstakeAllThatIOwn() public nonReentrant {
		uint256[] storage nfts = userNfts[msg.sender];
		for (uint i0 = (nfts).length; i0 > 0; i0--){
			unstake(nfts[(i0 - uint256(1))]);
		}
	}

/**
 * Function multipleWithdrawInterest
 * The function takes in 1 variable, (a list of zeros or positive integers) tokenIds. It can be called by functions both inside and outside of this contract. It does the following :
 * repeat length of tokenIds times with loop variable i0 :  (calls withdrawInterestWithoutUnstaking with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn with variable _tokenId as (tokenIds with element Loop Variable i0)), variable _tokenId as (tokenIds with element Loop Variable i0))
*/
	function multipleWithdrawInterest(uint256[] memory tokenIds) public {
		for (uint i0 = 0; i0 < (tokenIds).length; i0++){
			withdrawInterestWithoutUnstaking(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(tokenIds[i0]), tokenIds[i0]);
		}
	}

/**
 * Function withdrawAllInterestWithoutUnstaking
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable nfts with initial value userNfts with element the address that called this function
 * repeat length of nfts times with loop variable i0 :  (calls withdrawInterestWithoutUnstaking with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn with variable _tokenId as (nfts with element Loop Variable i0)), variable _tokenId as (nfts with element Loop Variable i0))
*/
	function withdrawAllInterestWithoutUnstaking() public {
		uint256[] storage nfts = userNfts[msg.sender];
		for (uint i0 = 0; i0 < (nfts).length; i0++){
			withdrawInterestWithoutUnstaking(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(nfts[i0]), nfts[i0]);
		}
	}

/**
 * Function updateRecordsWithLatestInterestRates
 * The function takes in 0 variables. It can only be called by other functions in this contract. It does the following :
 * repeat length of stakedAddresses times with loop variable i0 :  (creates an internal variable nfts with initial value userNfts with element stakedAddresses with element Loop Variable i0; and then repeat length of nfts times with loop variable i1 :  (creates an internal variable thisRecord with initial value informationAboutStakeScheme with element nfts with element Loop Variable i1; and then updates informationAboutStakeScheme (Element nfts with element Loop Variable i1) as Struct comprising (thisRecord with element staker), (thisRecord with element stakeTime), (minimum of current time, 1710252000), ((thisRecord with element accumulatedInterestToUpdateTime) + ((((minimum of current time, 1710252000) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate) * (1000000000000000000)) / (864000000))), (thisRecord with element amtWithdrawn)))
*/
	function updateRecordsWithLatestInterestRates() internal {
		for (uint i0 = 0; i0 < (stakedAddresses).length; i0++){
			uint256[] storage nfts = userNfts[stakedAddresses[i0]];
			for (uint i1 = 0; i1 < (nfts).length; i1++){
				record memory thisRecord = informationAboutStakeScheme[nfts[i1]];
				informationAboutStakeScheme[nfts[i1]]  = record (thisRecord.staker, thisRecord.stakeTime, minUIntPair(block.timestamp, uint256(1710252000)), (thisRecord.accumulatedInterestToUpdateTime + (((minUIntPair(block.timestamp, uint256(1710252000)) - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(864000000))), thisRecord.amtWithdrawn);
			}
		}
	}

/**
 * Function numberOfStakedTokenIDsOfAnAddress
 * The function takes in 1 variable, (an address) _address. It can be called by functions both inside and outside of this contract. It does the following :
 * returns length of (userNfts with element _address) as output
*/
	function numberOfStakedTokenIDsOfAnAddress(address _address) public view returns (uint256) {
		return (userNfts[_address]).length;
	}

/**
 * Function checkAddresses
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * returns stakedAddresses as output
*/
	function checkAddresses() public view returns (address[] memory) {
		return stakedAddresses;
	}

/**
 * Function stakedTokenIDsOfAnAddress
 * The function takes in 1 variable, (an address) _address. It can only be called by other functions in this contract. It does the following :
 * returns userNfts with element _address as output
*/
	function stakedTokenIDsOfAnAddress(address _address) internal view returns (uint256[] memory) {
		return userNfts[_address];
	}

/**
 * Function whichStakedTokenIDsOfAnAddress
 * The function takes in 2 variables, (an address) _address, and (zero or a positive integer) _counterIn. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable nfts with initial value userNfts with element _address
 * if ((length of nfts) - (1)) is greater than or equals to _counterIn then (returns nfts with element _counterIn as output) otherwise (returns 9999999 as output)
*/
	function whichStakedTokenIDsOfAnAddress(address _address, uint256 _counterIn) public view returns (uint256) {
		uint256[] storage nfts = userNfts[_address];
		if ((((nfts).length - uint256(1)) >= _counterIn)){
			return nfts[_counterIn];
		}else{
			return uint256(9999999);
		}
	}

/**
 * Function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element _tokenId
 * returns (thisRecord with element accumulatedInterestToUpdateTime) + ((((minimum of current time, 1710252000) - (thisRecord with element lastUpdateTime)) * (dailyInterestRate) * (1000000000000000000)) / (864000000)) as output
*/
	function interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(uint256 _tokenId) public view returns (uint256) {
		record memory thisRecord = informationAboutStakeScheme[_tokenId];
		return (thisRecord.accumulatedInterestToUpdateTime + (((minUIntPair(block.timestamp, uint256(1710252000)) - thisRecord.lastUpdateTime) * dailyInterestRate * uint256(1000000000000000000)) / uint256(864000000)));
	}

/**
 * Function withdrawInterestWithoutUnstaking
 * The function takes in 2 variables, (zero or a positive integer) _withdrawalAmt, and (zero or a positive integer) _tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * this function fails here
 * creates an internal variable totalInterestEarnedTillNow with initial value interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn with variable _tokenId as _tokenId
 * checks that _withdrawalAmt is less than or equals to totalInterestEarnedTillNow
 * creates an internal variable thisRecord with initial value informationAboutStakeScheme with element _tokenId
 * checks that (thisRecord with element staker) is equals to (the address that called this function)
 * updates informationAboutStakeScheme (Element _tokenId) as Struct comprising (thisRecord with element staker), (thisRecord with element stakeTime), (minimum of current time, 1710252000), ((totalInterestEarnedTillNow) - (_withdrawalAmt)), ((thisRecord with element amtWithdrawn) + (_withdrawalAmt))
 * checks that (ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to _withdrawalAmt
 * if _withdrawalAmt is strictly greater than 0 then (calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _withdrawalAmt)
 * updates totalWithdrawals as (totalWithdrawals) + (_withdrawalAmt)
*/
	function withdrawInterestWithoutUnstaking(uint256 _withdrawalAmt, uint256 _tokenId) public nonReentrant {
		uint256 totalInterestEarnedTillNow = interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(_tokenId);
		require((_withdrawalAmt <= totalInterestEarnedTillNow), "Withdrawn amount must be less than withdrawable amount");
		record memory thisRecord = informationAboutStakeScheme[_tokenId];
		require((thisRecord.staker == msg.sender), "You do not own this token");
		informationAboutStakeScheme[_tokenId]  = record (thisRecord.staker, thisRecord.stakeTime, minUIntPair(block.timestamp, uint256(1710252000)), (totalInterestEarnedTillNow - _withdrawalAmt), (thisRecord.amtWithdrawn + _withdrawalAmt));
		require((ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).balanceOf(address(this)) >= _withdrawalAmt), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_withdrawalAmt > uint256(0))){
			ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transfer(msg.sender, _withdrawalAmt);
		}
		totalWithdrawals  = (totalWithdrawals + _withdrawalAmt);
	}

/**
 * Function withdrawAllInterestFromATokenWithoutUnstaking
 * The function takes in 1 variable, (zero or a positive integer) _tokenId. It can only be called by functions outside of this contract. It does the following :
 * calls withdrawInterestWithoutUnstaking with variable _withdrawalAmt as (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn with variable _tokenId as _tokenId), variable _tokenId as _tokenId
*/
	function withdrawAllInterestFromATokenWithoutUnstaking(uint256 _tokenId) external {
		withdrawInterestWithoutUnstaking(interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(_tokenId), _tokenId);
	}

/**
 * Function totalAccumulatedInterest
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable total with initial value 0
 * repeat length of stakedAddresses times with loop variable i0 :  (creates an internal variable nfts with initial value userNfts with element stakedAddresses with element Loop Variable i0; and then repeat length of nfts times with loop variable i1 :  (updates total as (total) + (interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn with variable _tokenId as (nfts with element Loop Variable i1))))
 * returns total as output
*/
	function totalAccumulatedInterest() public view returns (uint256) {
		uint256 total = uint256(0);
		for (uint i0 = 0; i0 < (stakedAddresses).length; i0++){
			uint256[] storage nfts = userNfts[stakedAddresses[i0]];
			for (uint i1 = 0; i1 < (nfts).length; i1++){
				total  = (total + interestEarnedUpToNowBeforeTaxesAndNotYetWithdrawn(nfts[i1]));
			}
		}
		return total;
	}

/**
 * Function modifyDailyInterestRate
 * Notes for _dailyInterestRate : 10000 is one coin
 * The function takes in 1 variable, (zero or a positive integer) _dailyInterestRate. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _dailyInterestRate
 * calls updateRecordsWithLatestInterestRates
 * updates dailyInterestRate as _dailyInterestRate
*/
	function modifyDailyInterestRate(uint256 _dailyInterestRate) public onlyOwner {
		require((uint256(0) < _dailyInterestRate), "Interest rate needs to be larger than 0%");
		updateRecordsWithLatestInterestRates();
		dailyInterestRate  = _dailyInterestRate;
	}

/**
 * Function ownerWithdrawToken0
 * The function takes in 1 variable, (zero or a positive integer) _amt. It can be called by functions both inside and outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that (ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at balanceOf function  with variable recipient as (the address of this contract)) is greater than or equals to ((_amt) + (totalAccumulatedInterest))
 * if _amt is strictly greater than 0 then (calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transfer function  with variable recipient as (the address that called this function), variable amount as _amt)
*/
	function ownerWithdrawToken0(uint256 _amt) public onlyOwner {
		require((ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).balanceOf(address(this)) >= (_amt + totalAccumulatedInterest())), "Insufficient amount of the token in this contract to transfer out. Please contact the contract owner to top up the token.");
		if ((_amt > uint256(0))){
			ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transfer(msg.sender, _amt);
		}
	}
}
