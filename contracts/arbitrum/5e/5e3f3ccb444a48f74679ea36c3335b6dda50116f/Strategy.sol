// SPDX-License-Identifier: MIT

pragma solidity ^0.8.9;

import "./console.sol";
import "./SafeMath.sol";
import "./Math.sol";
import {SafeERC20, IERC20, Address} from "./SafeERC20.sol";

import {ICurveFi, Zap} from "./Curve.sol";
import {IUniswapV2Router02} from "./ISushiSwap.sol";
import {ISorbettiere} from "./Sorbettiere.sol";
import {BaseStrategy} from "./BaseStrategy.sol";
import {IGauge} from "./IGauge.sol";

contract Strategy is BaseStrategy {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    string internal stratName;

    address public constant SUSHISWAP = 0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506;
    address public constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
    address public constant MIM = 0xFEa7a6a0B346362BF88A9e4A88416B77a57D6c2A;
    address public constant USDC = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;
    address public constant USDT = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;
    uint256 public optimal; // optimal token to deposit to MIM pool

    ICurveFi public curvePool; // the pool that holds both MIM and 2CRV. Note - its not really used, since ZAP is used
    Zap public ZAP_CONTRACT = Zap(0x7544Fe3d184b6B55D6B36c3FCA1157eE0Ba30287);
    IGauge public gauge; // NOTE we leave the gauge set to zero. There is no gauge for arbitrum MIM. Might remove. But, there could be a gauge one day

    ISorbettiere public sorb;

    // Only handles 1 rewards token, which is our current scenario
    IERC20 public rewardsToken;
    bool public hasRewards;
    address[] public rewardsPath;

    // want is set in initialize(), based off vault.token()
    constructor(
        address _vault,
        string memory _name,
        address _sorb,
        address _curvePool,
        bool _hasRewards,
        address _rewardsToken
    ) BaseStrategy(_vault) {
        _initialize(_name, _sorb, _curvePool, _hasRewards, _rewardsToken);
    }

    // Initialize is used in combination with the constructor. Can only be called once
    // Initialize is more of a Proxy/Upgrade pattern. But we kept it here anyways. In reality
    // we could move all this logic into the constructor. But either is fine.
    function _initialize(
        string memory _name,
        address _sorb,
        address _curvePool,
        bool _hasRewards,
        address _rewardsToken
    ) internal {
        require(address(curvePool) == address(0)); // already initialized.
        stratName = _name;
        curvePool = ICurveFi(_curvePool);
        sorb = ISorbettiere(_sorb);
        IERC20(want).approve(_sorb, type(uint256).max);

        // Setup our rewards
        if (_hasRewards) {
            rewardsToken = IERC20(_rewardsToken);
            rewardsToken.approve(SUSHISWAP, type(uint256).max);
            rewardsPath = [address(rewardsToken), WETH, MIM];
            hasRewards = true;
        }

        // We approve the ZAP contract to zap any of the 3 tokens into MIM-2-CRV
        IERC20(MIM).approve(address(ZAP_CONTRACT), type(uint256).max);
        IERC20(USDC).approve(address(ZAP_CONTRACT), type(uint256).max);
        IERC20(USDT).safeApprove(address(ZAP_CONTRACT), type(uint256).max); // USDT requires safeApprove()
    }

    // This method returns any realized profits and should return the total amounts of profits
    // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
    // NOTE: DK - We removed any concept of Debt from our contracts for this version
    function prepareReturn() internal override returns (uint256 _profit) {
        if (hasRewards) {
            sorb.deposit(0, 0); // To get rewards and not withdraw tokens, call deposit with 0 tokens
            uint256 _rewardsBalance = rewardsToken.balanceOf(address(this));
            uint256 mimBal = IERC20(MIM).balanceOf(address(this));
            if (_rewardsBalance > 0) {
                _sellRewards(_rewardsBalance);
            }
            _rewardsBalance = rewardsToken.balanceOf(address(this));
        }

        // deposit our balance to Curve if we have any
        if (optimal == 0) {
            uint256 mimBal = IERC20(MIM).balanceOf(address(this));
            _profit = ZAP_CONTRACT.add_liquidity(address(want), [mimBal, 0, 0], 0);
        } else if (optimal == 1) {
            uint256 usdcBal = IERC20(USDC).balanceOf(address(this));
            _profit = ZAP_CONTRACT.add_liquidity(address(want), [0, usdcBal, 0], 0);
        } else {
            uint256 usdtBal = IERC20(USDT).balanceOf(address(this));
            _profit = ZAP_CONTRACT.add_liquidity(address(want), [0, 0, usdtBal], 0);
        }
    }

    // Sells our harvested SPELL token into one of the stable coins
    function _sellRewards(uint256 _amount) internal {
        IUniswapV2Router02(SUSHISWAP).swapExactTokensForTokens(_amount, uint256(0), rewardsPath, address(this), block.timestamp);
    }

    /**
     * @notice
     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
     *  to `want` (using the native decimal characteristics of `want`).
     * @dev
     *  In our case, we want to get the price of CRV2-MIM LP tokens in ETH.
     *
     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
     * @return The amount in `want` of `_amtInEth` converted to `want`
     **/
    function ethToWant(uint256 _amtInWei) public view override returns (uint256) {
        uint256 callCostInWant;
        if (_amtInWei > 0) {
            address[] memory ethPath = new address[](2);
            ethPath[0] = WETH;
            ethPath[1] = MIM; // we use the WETH/MIM pool, it has the most liquidity on sushi arbitrum

            uint256[] memory _callCostInMIMTuple = IUniswapV2Router02(SUSHISWAP).getAmountsOut(_amtInWei, ethPath);

            // The last element in the array returned is MIM amount
            uint256 _callCostInMIM = _callCostInMIMTuple[_callCostInMIMTuple.length - 1];
            // Here we "zap" MIM into MIM-2CRV
            callCostInWant = ZAP_CONTRACT.calc_token_amount(address(want), [_callCostInMIM, 0, 0], true);
        }

        // Now, starting with _amtInWei input by user, we have an output of MIM-2CRV.
        return callCostInWant;
    }

    // Tokens that cannot be pulled out by sweep()
    function _protectedTokens() internal view override returns (address[] memory) {
        address[] memory protectedTokens = new address[](2);
        protectedTokens[0] = address(rewardsToken); // SPELL
        return protectedTokens;
    }

    // The strategies balance on the Sorbettiere
    function balanceOfSorb() public view returns (uint256) {
        return sorb.userInfo(0, address(this)).amount;
    }

    // The total estimated assets. This includes current want balance of strategy
    // And want balance staked in the Sorb
    function estimatedTotalAssets() public view override returns (uint256) {
        return balanceOfWant().add(balanceOfSorb());
    }

    // Set optimal token to sell harvested funds for depositing to Curve.
    // Default is MIM, but can be set to USDC or USDT as needed by strategist or governance.
    function setOptimal(uint256 _optimal) external onlyAuthorized {
        if (_optimal == 0) {
            if (hasRewards) {
                rewardsPath[2] = MIM;
            }
            optimal = 0;
        } else if (_optimal == 1) {
            if (hasRewards) {
                rewardsPath[2] = USDC;
            }
            optimal = 1;
        } else if (_optimal == 2) {
            if (hasRewards) {
                rewardsPath[2] = USDT;
            }
            optimal = 2;
        } else {
            revert("incorrect token");
        }
    }

    function name() external view override returns (string memory) {
        return stratName;
    }

    function balanceOfWant() public view returns (uint256) {
        return want.balanceOf(address(this));
    }

    // Send want token to Sorbettiere to earn SPELL
    // NOTE - _debtOutstanding and the concept of debt was removed
    function adjustPosition() public override {
        if (emergencyExit) {
            return;
        }
        // Send all of our LP tokens to Sorbettiere if we have any
        uint256 _toInvest = balanceOfWant();
        if (_toInvest > 0) {
            sorb.deposit(0, _toInvest);
        }
    }

    // Called upon by withdraw(). Earns the Spell and deposits it to the Strategy. adjustPosition()
    // should be called after
    // NOTE - we removed the concept of having a loss from this function. We consider that all is safe, for now
    function liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _liquidatedAmount) {
        uint256 _wantBal = balanceOfWant();
        if (_amountNeeded > _wantBal) {
            // check if we have enough free funds to cover the withdrawal
            uint256 _stakedBal = balanceOfSorb();
            if (_stakedBal > 0) {
                sorb.withdraw(0, Math.min(_stakedBal, _amountNeeded.sub(_wantBal)));
            }
            uint256 _withdrawnBal = balanceOfWant();
            _liquidatedAmount = Math.min(_amountNeeded, _withdrawnBal);
        } else {
            // we have enough balance to cover the liquidation available
            return _amountNeeded;
        }
    }

    // Fire sale, get rid of it all! Just like liquidatePosition(), but you get rid of everything.
    function liquidateAllPositions() internal override returns (uint256) {
        uint256 _stakedBal = balanceOfSorb();
        if (_stakedBal > 0) {
            sorb.withdraw(0, _stakedBal);
        }
        return balanceOfWant();
    }
}

