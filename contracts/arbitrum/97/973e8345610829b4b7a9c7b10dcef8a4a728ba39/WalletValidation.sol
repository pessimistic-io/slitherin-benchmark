// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity 0.8.17;

import "./DataLib.sol";
import "./IValidation.sol";

/**
 * @title WalletValidation - Manages FunWallet Validation Contracts
 * @dev Uses a linked list to store the validations because the code generated by the solidity compiler
 *      is more efficient than using a dynamic array. Adapted from Safe Multisig Wallet by Gnosis.
 * @author Caleb Sirak - @csirak1528
 */

contract WalletValidation {
	mapping(address => address) internal validations;
	uint256 private validationCount;
	uint256[50] private __gap;
	address private constant RANGE_LIMITER = address(1);

	/**
	 * @notice Sets the initial storage of the contract.
	 * @param validationData Abi encoded arrays of validation address's and the ambiguous init initCallData.
	 * @dev The validationData is encoded as follows: abi.encode([validationId1, validationId2, ...], [initCallData1, initCallData2, ...])
	 * @dev The validation is an address of a contract that implements IValidation.
	 * @dev The initCallData is ambiguous because it is dependent on the validation scheme of the wallet.
	 */
	function initValidations(bytes calldata validationData) public {
		// require no previous validations
		require(validations[RANGE_LIMITER] == address(0), "FW511");

		// decode parameters
		(address[] memory addrs, bytes[] memory initCallData) = abi.decode(validationData, (address[], bytes[]));

		// validate parameters lengths are the same and there are more than 0 validations
		require(addrs.length == initCallData.length && addrs.length > 0, "FW512");

		address currentAddr = RANGE_LIMITER;
		for (uint8 i = 0; i < initCallData.length; ++i) {
			require(currentAddr != addrs[i], "FW513");
			_requireValidValidation(addrs[i]);
			// link current validation to next validation
			validations[currentAddr] = addrs[i];
			currentAddr = addrs[i];
			IValidation(addrs[i]).init(initCallData[i]);
		}
		// link last validation
		validations[currentAddr] = RANGE_LIMITER;
		validationCount = addrs.length;
	}

	/**
	 * @notice Adds the verification `verification` calls the initalization dataa `initdata`.
	 * @param validation New verification address.
	 * @param initdata Ambiguous initalization data.
	 */
	function addValidation(address validation, bytes calldata initdata) public {
		require(msg.sender == address(this), "FW520");
		_requireValidValidation(validation);
		validations[validation] = validations[RANGE_LIMITER];
		validations[RANGE_LIMITER] = validation;
		++validationCount;

		if (initdata.length > 0) {
			IValidation(validation).init(initdata);
		}
	}

	/**
	 * @notice Removes the validation `validation` from the FunWallet.
	 * @param prevValidation Validation that pointed to the validation to be removed in the linked list
	 * @param validation Validation id to be removed.
	 */
	function removeValidation(address prevValidation, address validation) public {
		require(msg.sender == address(this), "FW521");
		_requireValidValidationFormat(validation, true);
		_requireValidPrevValidation(prevValidation, validation);
		validations[prevValidation] = validations[validation];
		validations[validation] = address(0);
		validationCount--;
	}

	/**
	 * @notice Replaces the validation `oldValidation` in the FunWallet with `newValidation`.
	 * @param prevValidation Validation that pointed to the validation to be replaced in the linked list
	 * @param oldValidation Validation id to be replaced.
	 * @param newValidation New validation id.
	 * @param newValidationInitData New validation ambiguous initialization data.
	 */
	function updateValidation(address prevValidation, address oldValidation, address newValidation, bytes calldata newValidationInitData) public {
		require(msg.sender == address(this), "FW522");
		_requireValidValidation(newValidation);
		_requireValidValidationFormat(oldValidation, true);
		_requireValidPrevValidation(prevValidation, oldValidation);
		validations[newValidation] = validations[oldValidation];
		validations[prevValidation] = newValidation;
		validations[oldValidation] = address(0);
		IValidation(newValidation).init(newValidationInitData);
	}

	/**
	 * @notice Returns the next validation in linked list.
	 * @param validation Validation id.
	 * @return Validation
	 */
	function getNextValidation(address validation) external view returns (address) {
		return validations[validation];
	}

	/**
	 * @notice Returns the validation count.
	 * @return uint256
	 */
	function getValidationCount() public view returns (uint256) {
		return validationCount;
	}

	/**
	 * @notice Returns a list of FunWallet validation contracts.
	 * @return Array of FunWallet validations.
	 */
	function getValidations() public view returns (address[] memory) {
		require(validationCount > 0, "FW525");
		address[] memory out = new address[](validationCount);
		uint256 index = 0;
		address currentValidation = validations[RANGE_LIMITER];
		while (currentValidation != RANGE_LIMITER) {
			out[index] = currentValidation;
			currentValidation = validations[currentValidation];
			++index;
		}
		return out;
	}

	/**
	 * @dev Validates a userop among all validations in the wallet.
	 * @notice If the any of the validations fail the function will return the first failed value.
	 * @param userOp The user operation
	 * @param userOpHash The hash of the user operation
	 * @return sigTimeRange The out of the validation. Expected values are 0 and 1 for pass and fail.
	 */
	function _validateUserOp(UserOperation calldata userOp, bytes32 userOpHash) internal view returns (uint256 sigTimeRange) {
		require(userOp.signature.length > 0, "FW514");
		address[] memory _validations = getValidations();
		sigTimeRange = 0;
		ValidationData memory data;
		data.validUntil = type(uint48).max;
		for (uint8 i = 0; i < _validations.length; ++i) {
			sigTimeRange = IValidation(_validations[i]).authenticateUserOp(userOp, userOpHash, "");
			if (uint160(sigTimeRange) != 0) {
				return sigTimeRange;
			}
			_updateValidationData(data, sigTimeRange);
		}
		if (data.validUntil == type(uint48).max) {
			data.validUntil = 0;
		}
		return DataLib.getValidationData(data);
	}

	/**
	 * @notice Checks if an action is valid based on target, value, data, signature, and hash.
	 * @param target The address of the contract being called.
	 * @param value The value being transferred in the action.
	 * @param data The calldata for the action.
	 * @param signature The user's signature for the action.
	 * @param _hash The hash of the user operation.
	 * @return sigTimeRange A boolean indicating whether the action is valid.

	 */
	function _isValidAction(address target, uint256 value, bytes memory data, bytes memory signature, bytes32 _hash) internal view returns (uint256) {
		address[] memory _validations = getValidations();
		ValidationData memory vdata;
		vdata.validUntil = type(uint48).max;
		for (uint8 i = 0; i < _validations.length; ++i) {
			uint256 sigTimeRange = IValidation(_validations[i]).isValidAction(target, value, data, signature, _hash);
			if (uint160(sigTimeRange) != 0) {
				return sigTimeRange;
			}
			_updateValidationData(vdata, sigTimeRange);
		}
		if (vdata.validUntil == type(uint48).max) {
			vdata.validUntil = 0;
		}
		return DataLib.getValidationData(vdata);
	}

	function _updateValidationData(ValidationData memory vdata, uint256 newData) internal pure {
		if (newData == 0) {
			return;
		}
		ValidationData memory tempdata = DataLib.parseValidationData(newData);
		if (vdata.validUntil > tempdata.validUntil && tempdata.validUntil != 0) {
			vdata.validUntil = tempdata.validUntil;
		}
		if (vdata.validAfter < tempdata.validAfter) {
			vdata.validAfter = tempdata.validAfter;
		}
	}

	/**
	 * @notice Returns true if `validation` is a validation of the FunWallet.
	 * @param validation validation contract address to check
	 * @return Boolean if validation is a validation of the FunWallet.
	 */
	function isValidation(address validation) public view returns (bool) {
		return validations[validation] != address(0) && validation != RANGE_LIMITER;
	}

	/**
	 * @notice Reverts if `validation` is already a validation or if `_requireValidValidation` with the `contractValid` flag set to false reverts.
	 * @param validation validation id to be tested.
	 */
	function _requireValidValidation(address validation) internal view {
		_requireValidValidationFormat(validation, false);
		require(!isValidation(validation), "FW516");
	}

	/**
	 * @notice Reverts if `validation` is equal to an id of zero, the RANGE_LIMITER or potentially the wallet address.
	 * @param validation validation id to be tested.
	 * @param contractValid If set to true then the validation id will not be checked against the wallet Address.
	 */
	function _requireValidValidationFormat(address validation, bool contractValid) internal view {
		require(validation != address(0) && validation != RANGE_LIMITER && (contractValid || validation != address(this)), "FW517");
	}

	/**
	 * @notice Reverts if `prevValidation` is not linked to the validation.
	 * @param prevValidation prevValidation to be tested.
	 * @param validation validation to be tested.
	 */
	function _requireValidPrevValidation(address prevValidation, address validation) internal view {
		require(validations[prevValidation] == validation, "FW518");
	}

	function _requireFromEntryPoint() internal view virtual {}
}

