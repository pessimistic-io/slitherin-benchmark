// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./IterableMappingBool.sol";
import "./ERC20.sol";
import "./Ownable.sol";
import "./IxTIG.sol";
import "./IGovernanceStaking.sol";
import "./IExtraRewards.sol";
import "./SafeERC20.sol";

contract xTIG is IxTIG, ERC20, Ownable {

    using SafeERC20 for IERC20;
    using IterableMappingBool for IterableMappingBool.Map;

    // Constants
    uint256 public constant DIVISION_CONSTANT = 1e10;
    uint256 public constant EPOCH_PERIOD = 1 days;
    uint256 public constant MAX_VESTING_PERIOD = 30 days;
    uint256 public constant MAX_EARLY_UNLOCK_PENALTY = 75e8;

    // Contracts and addresses
    IERC20 public immutable tig;
    IGovernanceStaking public immutable staking;
    address public treasury;
    address public trading;
    IExtraRewards public extraRewards;

    // xTIG settings
    uint256 public vestingPeriod = 30 days;
    uint256 public earlyUnlockPenalty = 5e9;
    mapping(address => uint256) public tigAssetValue;
    IterableMappingBool.Map private rewardTokens;
    mapping(address => bool) public canAddFees;

    // Reward distribution logic
    mapping(uint256 => uint256) public epochFeesGenerated;
    mapping(uint256 => uint256) public epochAllocation;
    mapping(uint256 => uint256) public epochAllocationClaimed;
    mapping(address => uint256) public accRewardsPerToken;
    mapping(address => mapping(address => uint256)) public userPaid; // user => token => amount
    mapping(uint256 => mapping(address => uint256)) public feesGenerated; // 7d epoch => trader => fees
    mapping(address => RewardBatch[]) public userRewards;

    // Helpers for UI
    mapping(address => uint256) public lastClaimedEpoch; // Last xTIG claim / createVest
    mapping(address => bool) public hasEarnedBefore; // Has earned xTIG before

    /**
     * @dev Throws if called by any account that is not permissioned to store fees generated by trading.
     */
    modifier onlyPermissioned() {
        require(canAddFees[msg.sender], "!Permission");
        _;
    }

    /**
     * @notice Constructor to initialize the contract
     * @param name_ Token name
     * @param symbol_ Token symbol
     * @param _tig The TIG token address
     * @param _staking The staking contract address
     * @param _treasury The treasury address
     */
    constructor(string memory name_, string memory symbol_, IERC20 _tig, IGovernanceStaking _staking, address _treasury) ERC20(name_, symbol_) {
        require(
            address(_tig) != address(0) &&
            address(_staking) != address(0) &&
            _treasury != address(0),
            "Zero address"
        );
        tig = _tig;
        staking = _staking;
        treasury = _treasury;
        tig.approve(address(_staking), type(uint256).max);
    }

    /**
     * @notice Create vest xTIG from a specified block epoch to current epoch
     * @param _from Epoch to start vesting xTIG from
     */
    function createVest(uint256 _from) external {
        uint256 _to = block.timestamp / EPOCH_PERIOD;
        createVestTo(_from, _to);
    }

    /**
     * @notice Create vest xTIG from a specified block epoch to another specified epoch
     * @param _from Epoch to start vesting xTIG from
     * @param _to Epoch to end at
     */
    function createVestTo(uint256 _from, uint256 _to) public {
        uint256 _totalAmount;
        for (uint256 _epoch=_from; _epoch<_to; _epoch++) {
            if (epochFeesGenerated[_epoch] == 0) {
                continue;
            }
            uint256 _amount = epochAllocation[_epoch] * feesGenerated[_epoch][msg.sender] / epochFeesGenerated[_epoch];
            if (_amount == 0) {
                continue;
            }
            _totalAmount += _amount;
            delete feesGenerated[_epoch][msg.sender];
            epochAllocationClaimed[_epoch] += _amount;
        }
        require(_totalAmount != 0, "No fees generated by trader");
        lastClaimedEpoch[msg.sender] = _to;
        _claim(msg.sender);
        userRewards[msg.sender].push(RewardBatch(_totalAmount, block.timestamp + vestingPeriod));
        _mint(msg.sender, _totalAmount);
        _updateUserPaid(msg.sender);
        emit TigVested(msg.sender, _totalAmount);
        if (vestingPeriod == 0) {
            claimTig();
        }
    }

    function claimTig() public {
        uint256 _length = userRewards[msg.sender].length;
        claimTigRanged(0, _length);
    }
    /**
     * @dev Claims the TIG rewards for the caller.
     * @notice This function allows the caller to claim their accumulated TIG rewards that have passed the vesting period.
     * @param _from The index of the first reward to claim.
     * @param _to The last index of the range of reward to claim, exclusive. This is to prevent gas limit from being exceeded.
     */
    function claimTigRanged(uint256 _from, uint256 _to) public {
        _claim(msg.sender);
        RewardBatch[] storage rewardsStorage = userRewards[msg.sender];
        uint256 _length = rewardsStorage.length;
        require(_length >= _to, "_to exceeds len");

        uint256 _amount;
        while(_from < _to) {
            RewardBatch memory reward = rewardsStorage[_from];
            if (block.timestamp >= reward.unlockTime) {
                _amount += reward.amount;
                rewardsStorage[_from] = rewardsStorage[_length - 1];
                rewardsStorage.pop();
                _length--;
                _to--;
            } else {
                _from++;
            }
        }

        require(_amount != 0, "No TIG to claim");
        _burn(msg.sender, _amount);
        staking.unstake(_amount);
        _updateUserPaid(msg.sender);
        tig.safeTransfer(msg.sender, _amount);
        emit TigClaimed(msg.sender, _amount);
    }



    function earlyClaimTig() external {
        uint256 _length = userRewards[msg.sender].length;
        earlyClaimTigRanged(0, _length);
    }
    /**
     * @dev Claims the TIG rewards for the caller, with an early unlock penalty.
     * @notice Claim accumulated TIG rewards, with a penalty applied to TIG that have not passed the vesting period.
     * @param _from The index of the first reward to claim.
     * @param _to The last index of the range of reward to claim, exclusive. This is to prevent gas limit from being exceeded.
     */
    function earlyClaimTigRanged(uint256 _from, uint256 _to) public {
        RewardBatch[] storage rewardsStorage = userRewards[msg.sender];
        uint256 _length = rewardsStorage.length;
        require(_length != 0, "No TIG to claim");
        require(_length >= _to, "_to exceeds len");
        _claim(msg.sender);

        uint256 _unstakeAmount;
        uint256 _userAmount;
        while (_from < _to) {
            RewardBatch memory reward = rewardsStorage[_from];
            _unstakeAmount += reward.amount;
            if (block.timestamp >= reward.unlockTime) {
                _userAmount += reward.amount;
            } else {
                _userAmount += reward.amount*(DIVISION_CONSTANT-earlyUnlockPenalty)/DIVISION_CONSTANT;
            }

            rewardsStorage[_from] = rewardsStorage[_length - 1];
            rewardsStorage.pop();
            _length--;
            _to--;
        }

        _burn(msg.sender, _unstakeAmount);
        staking.unstake(_unstakeAmount);
        uint256 _amountForTreasury = _unstakeAmount-_userAmount;
        _updateUserPaid(msg.sender);
        tig.safeTransfer(treasury, _amountForTreasury);
        tig.safeTransfer(msg.sender, _userAmount);
        emit EarlyTigClaimed(msg.sender, _userAmount, _amountForTreasury);
    }

    /**
     * @dev Claims the fees generated by the caller.
     * @notice This function allows the caller to claim the TIG staking rewards earned by holding xTIG.
     */
    function claimFees() external {
        _claim(msg.sender);
    }

    /**
     * @dev Adds fees generated by a trader to the contract.
     * @param _trader The address of the trader.
     * @param _tigAsset The address of the asset in which fees were generated.
     * @param _fees The amount of fees generated by the trader in the specified asset.
     * @notice This function allows a permissioned address to add fees generated by a trader to the contract.
     */
    function addFees(address _trader, address _tigAsset, uint256 _fees) external onlyPermissioned {
        uint256 _value = _fees * tigAssetValue[_tigAsset] / 1e18;
        uint256 _epoch = block.timestamp / EPOCH_PERIOD;
        feesGenerated[_epoch][_trader] += _value;
        if (!hasEarnedBefore[_trader]) {
            hasEarnedBefore[_trader] = true;
            lastClaimedEpoch[_trader] = _epoch;
        }
        epochFeesGenerated[_epoch] += _value;
        emit FeesAdded(_trader, _tigAsset, _fees, _value);
    }

    /**
     * @dev Adds TIG rewards to the contract for a specific epoch.
     * @param _epoch The epoch for which to add the TIG rewards.
     * @param _amount The amount of TIG rewards to add for the specified epoch.
     * @notice This function allows the contract owner to add TIG rewards to the contract for a specific epoch.
     */
    function addTigRewards(uint256 _epoch, uint256 _amount) external onlyOwner {
        require(_epoch >= block.timestamp / EPOCH_PERIOD, "No past epochs");
        tig.safeTransferFrom(msg.sender, address(this), _amount);
        epochAllocation[_epoch] += _amount;
        _distribute();
        staking.stake(_amount, 0);
        emit TigRewardsAdded(msg.sender, _amount);
    }

    /**
     * @dev Sets the value of a tigAsset used in fee calculations.
     * @param _tigAsset The address of the tigAsset.
     * @param _value The value of the tigAsset.
     * @notice This function allows the contract owner to set the value of a tigAsset used in fee calculations.
     */
    function setTigAssetValue(address _tigAsset, uint256 _value) external onlyOwner {
        tigAssetValue[_tigAsset] = _value;
        emit TigAssetValueUpdated(_tigAsset, _value);
    }

    /**
     * @dev Sets the permission for an address to add fees generated by traders.
     * @param _address The address for which to set the fee permission.
     * @param _allowed True to allow the address to add fees, false to disallow.
     * @notice This function allows the contract owner to set the permission for an address to add fees generated by traders.
     */
    function setCanAddFees(address _address, bool _allowed) external onlyOwner {
        canAddFees[_address] = _allowed;
        emit FeePermissionUpdated(_address, _allowed);
    }

    /**
     * @dev Sets the treasury address for receiving assets.
     * @param _address The address of the treasury.
     * @notice This function allows the contract owner to set the treasury address for receiving assets.
     */
    function setTreasury(address _address) external onlyOwner {
        require(_address != address(0), "Zero address");
        treasury = _address;
        emit TreasuryUpdated(_address);
    }

    /**
     * @dev Sets the contract address for optional extra rewards.
     * @param _address The address of the contract implementing the IExtraRewards interface.
     * @notice This function allows the contract owner to set the contract address for extra rewards.
     */
    function setExtraRewards(address _address) external onlyOwner {
        _distribute();
        extraRewards = IExtraRewards(_address);
        emit SetExtraRewards(_address);
    }

    /**
     * @dev Sets the vesting period for xTIG tokens.
     * @param _time The new vesting period in seconds.
     * @notice This function allows the contract owner to set the vesting period for xTIG tokens.
     */
    function setVestingPeriod(uint256 _time) external onlyOwner {
        require(_time <= MAX_VESTING_PERIOD, "Period too long");
        vestingPeriod = _time;
        emit VestingPeriodUpdated(_time);
    }

    /**
     * @dev Sets the early unlock penalty for xTIG tokens.
     * @param _percent The new early unlock penalty as a percentage.
     * @notice This function allows the contract owner to set the early unlock penalty for xTIG tokens.
     */
    function setEarlyUnlockPenalty(uint256 _percent) external onlyOwner {
        require(_percent <= MAX_EARLY_UNLOCK_PENALTY, "Bad percent");
        earlyUnlockPenalty = _percent;
        emit EarlyUnlockPenaltyUpdated(_percent);
    }

    /**
     * @dev Whitelists a reward token for distribution.
     * @param _rewardToken The address of the reward token to whitelist.
     * @notice This function allows the contract owner to whitelist a reward token for distribution.
     */
    function whitelistReward(address _rewardToken) external onlyOwner {
        require(!rewardTokens.get(_rewardToken), "Already whitelisted");
        rewardTokens.set(_rewardToken);
        emit TokenWhitelisted(_rewardToken);
    }

    /**
     * @dev Removes a reward token from the whitelist.
     * @param _rewardToken The address of the reward token to remove from the whitelist.
     * @notice This function allows the contract owner to remove a reward token from the whitelist.
     */
    function unwhitelistReward(address _rewardToken) external onlyOwner {
        require(rewardTokens.get(_rewardToken), "Not whitelisted");
        rewardTokens.remove(_rewardToken);
        emit TokenUnwhitelisted(_rewardToken);
    }

    /**
     * @dev Returns the amount of TIG staking rewards this xTIG contract has earned.
     * @param _token The address of the reward token for which to calculate pending rewards.
     * @return The amount of reward tokens pending.
     * @notice This function allows the caller to check the amount of TIG staking rewards this xTIG contract has earned.
     */
    function contractPending(address _token) public view returns (uint256) {
        return staking.pending(address(this), _token);
    }

    /**
     * @dev Returns the amount of extra rewards this xTIG contract has earned.
     * @param _token The address of the reward token for which to calculate pending rewards.
     * @return The amount of reward tokens pending.
     * @notice This function allows the caller to check the amount of extra rewards this xTIG contract has earned.
     */
    function extraRewardsPending(address _token) public view returns (uint256) {
        if (address(extraRewards) == address(0)) return 0;
        return extraRewards.pending(address(this), _token);
    }

    /**
     * @dev Returns the amount of rewards pending for the caller.
     * @param _user The address of the user for which to calculate pending rewards.
     * @param _token The address of the token for which to calculate pending rewards.
     * @return The amount of rewards pending for the caller.
     * @notice This function allows the caller to check the amount of an user's pending rewards.
     */
    function pending(address _user, address _token) public view returns (uint256) {
        if (stakedTigBalance() == 0 || totalSupply() == 0) return 0;
        return balanceOf(_user) * (accRewardsPerToken[_token] + (contractPending(_token)*1e18/stakedTigBalance()) + (extraRewardsPending(_token)*1e18/totalSupply())) / 1e18 - userPaid[_user][_token];
    }

    /**
     * @dev Returns the amount of TIG pending for the caller as a result of xTIG vesting.
     * @param _user The address of the user for which to calculate pending TIG.
     * @return The amount of TIG pending for the caller as a result of xTIG vesting.
     * @notice This function allows the caller to check the amount of TIG pending for the caller as a result of xTIG vesting.
     */
    function pendingTig(address _user) external view returns (uint256) {
        RewardBatch[] memory rewards = userRewards[_user];
        uint256 _length = rewards.length;
        uint256 _amount;
        for (uint256 i=0; i<_length; i++) {
            RewardBatch memory reward = rewards[i];
            if (block.timestamp >= reward.unlockTime) {
                _amount = _amount + reward.amount;
            }
        }   
        return _amount;     
    }

    /**
     * @dev Returns the amount of TIG pending for the caller with an early unlock penalty.
     * @param _user The address of the user for which to calculate pending rewards.
     * @return The amount of TIG pending for the caller with an early unlock penalty.
     * @notice This function allows the caller to check the amount of TIG pending for the caller with an early unlock penalty.
     */
    function pendingEarlyTig(address _user) external view returns (uint256) {
        RewardBatch[] memory rewards = userRewards[_user];
        uint256 _length = rewards.length;
        uint256 _amount;
        for (uint256 i=0; i<_length; i++) {
            RewardBatch memory reward = rewards[i];
            if (block.timestamp >= reward.unlockTime) {
                _amount += reward.amount;
            } else {
                _amount += reward.amount*(DIVISION_CONSTANT-earlyUnlockPenalty)/DIVISION_CONSTANT;
            }
        }
        return _amount;  
    }

    /**
     * @dev Returns the amount of upcoming xTIG tokens that the caller will receive in the current epoch.
     * @param _user The address of the user for which to calculate upcoming xTIG tokens.
     * @return The amount of upcoming xTIG tokens that the caller will receive in the current epoch.
     * @notice This function allows the caller to check the amount of upcoming xTIG tokens they will receive in the current epoch.
     */
    function upcomingXTig(address _user) external view returns (uint256) {
        uint256 _epoch = block.timestamp / EPOCH_PERIOD;
        if (epochFeesGenerated[_epoch] == 0) return 0;
        return epochAllocation[_epoch] * feesGenerated[_epoch][_user] / epochFeesGenerated[_epoch];
    }

    /**
     * @dev Returns the amount of xTIG tokens claimable by the caller from a specified epoch to current epoch.
     * @param _user The address of the user for which to calculate claimable xTIG tokens.
     * @param _from The starting epoch for calculating claimable xTIG tokens.
     * @return The amount of xTIG tokens claimable by the caller from a specified epoch to current epoch.
     * @notice This function allows the caller to check the amount of xTIG tokens claimable from a specified epoch to current epoch.
     */
    function claimableXTig(address _user, uint256 _from) external view returns (uint256) {
        uint256 _to = block.timestamp / EPOCH_PERIOD;
        return claimableXTigTo(_user, _from, _to);
    }

    /**
     * @dev Returns the amount of xTIG tokens claimable by the caller in a specific epoch range.
     * @param _user The address of the user for which to calculate claimable xTIG tokens.
     * @param _from The starting epoch for calculating claimable xTIG tokens.
     * @return The amount of xTIG tokens claimable by the caller in the specified epoch range.
     * @notice This function allows the caller to check the amount of xTIG tokens claimable in a specific epoch range.
     */
    function claimableXTigTo(address _user, uint256 _from, uint256 _to) public view returns (uint256) {
        uint256 _amount;
        for (uint256 _epoch=_from; _epoch<_to; _epoch++) {
            if (epochFeesGenerated[_epoch] == 0) {
                continue;
            }
            _amount += epochAllocation[_epoch] * feesGenerated[_epoch][_user] / epochFeesGenerated[_epoch];
        }
        return _amount;
    }

    /**
     * @dev Returns the total amount of TIG tokens staked by the contract.
     * @return The total amount of TIG tokens staked by the contract.
     * @notice This function allows anyone to check the total amount of TIG tokens staked by the contract.
     */
    function stakedTigBalance() public view returns (uint256) {
        return staking.userStaked(address(this));
    }

    /**
     * @dev Returns an array of vested xTIG batches for the given user.
     * @param _user The address of the user for which to retrieve vested xTIG batches.
     * @return An array of vested xTIG batches for the given user.
     * @notice This function allows the caller to retrieve an array of vested xTIG batches for the given user.
     */
    function userRewardBatches(address _user) external view returns (RewardBatch[] memory) {
        return userRewards[_user];
    }

    /**
     * @dev Returns the unclaimed allocation for a specific epoch.
     * @param _epoch The epoch for which to retrieve the unclaimed allocation.
     * @return The unclaimed allocation for the specified epoch.
     * @notice This function allows the caller to retrieve the unclaimed allocation for a specific epoch.
     */
    function unclaimedAllocation(uint256 _epoch) external view returns (uint256) {
        return epochAllocation[_epoch] - epochAllocationClaimed[_epoch];
    }

    /**
     * @dev Returns the current epoch.
     * @return The current epoch.
     * @notice This function allows anyone to check the current epoch.
     */
    function currentEpoch() external view returns (uint256) {
        return block.timestamp / EPOCH_PERIOD;
    }

    /**
     * @dev Internal function to claim rewards for the caller.
     * @param _user The address of the user for which to claim rewards.
     * @notice This function allows the contract to internally claim rewards for the caller.
     */
    function _claim(address _user) internal {
        _distribute();
        address[] memory _tokens = rewardTokens.keys;
        uint256 _len = _tokens.length;
        for (uint256 i=0; i<_len; i++) {
            address _token = _tokens[i];
            uint256 _pending = pending(_user, _token);
            if (_pending != 0) {
                userPaid[_user][_token] += _pending;
                IERC20(_token).safeTransfer(_user, _pending);
                emit RewardClaimed(_user, _pending);
            }
        }
    }

    /**
     * @dev Internal function to distribute rewards among xTIG holders.
     * @notice This function allows the contract to internally distribute rewards among xTIG holders.
     */
    function _distribute() internal {
        uint256 _length = rewardTokens.size();
        uint256[] memory _balancesBefore = new uint256[](_length);
        for (uint256 i=0; i<_length; i++) {
            address _token = rewardTokens.getKeyAtIndex(i);
            _balancesBefore[i] = IERC20(_token).balanceOf(address(this));
        }
        if (address(extraRewards) != address(0)) {
            extraRewards.claim();
        }
        staking.claim();
        for (uint256 i=0; i<_length; i++) {
            address _token = rewardTokens.getKeyAtIndex(i);
            uint256 _amount = IERC20(_token).balanceOf(address(this)) - _balancesBefore[i];
            if (stakedTigBalance() == 0 || totalSupply() == 0) {
                IERC20(_token).safeTransfer(treasury, _amount);
                continue;
            }
            uint256 _amountPerStakedTig = _amount*1e18/stakedTigBalance();
            accRewardsPerToken[_token] += _amountPerStakedTig;
            IERC20(_token).safeTransfer(treasury, _amount-_amount*totalSupply()/stakedTigBalance());
        }
    }

    /**
     * @dev Internal function to update the paid rewards for a user.
     * @param _user The address of the user for which to update the paid rewards.
     * @notice This function allows the contract to internally update the paid rewards for a user.
     */
    function _updateUserPaid(address _user) internal {
        address[] memory _tokens = rewardTokens.keys;
        uint256 _len = _tokens.length;
        for (uint256 i=0; i<_len; i++) {
            address _token = _tokens[i];
            userPaid[_user][_token] = balanceOf(_user) * accRewardsPerToken[_token] / 1e18;
        }
    }

    /**
     * @dev Override transfer to disallow transfers.
     */
    function _transfer(address, address, uint256) internal override {
        revert("xTIG: No transfer");
    }
}

