// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.4;
pragma abicoder v2;

import "./IERC20.sol";
import "./IERC721.sol";
import "./SafeERC20.sol";
import "./SafeMath.sol";
import "./Initializable.sol";
import "./TickMath.sol";
import "./FullMath.sol";
import "./IHypervisor.sol";
import "./IPersonalVault.sol";
import "./IManager.sol";
import "./IStrategy.sol";
import "./IVault.sol";
import "./IPositionRouterCallbackReceiver.sol";
import "./IRouter.sol";
import "./IPositionRouter.sol";
import "./IOrderBook.sol";

import "./console.sol";

interface IERC20Metadata is IERC20 {
  function decimals() external view returns (uint8);
}

/**
 * @notice
 *  need to restrict the vault to have only 1 open position at the same time, if not, difficult to manage positions because of async operations
 */
contract PerpetualVault is IPositionRouterCallbackReceiver, Initializable {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;

  struct PositionInfo {
    address collateralToken;
    address indexToken;
    bool isLong;
    uint256 size;
    uint256 collateral;
    uint256 averagePrice;
    uint256 entryFundingRate;
    uint256 reserveAmount;
    uint256  realisedPnl;
    bool isPositivePnl;
    uint256 lastIncreasedTime;
  }

  struct PositionKeyInfo {              //  positionKey = keccak256(abi.encodePacked(_account=address(this), _collateralToken, _indexToken, _isLong)
    address collateralToken;
    address indexToken;
    bool isLong;
  }

  struct PositionRequestQueue {
    bytes32 requestKey;                 //  requestKey generated by PositionRouter contract of GMX
    address tokenIn;
    address indexToken;
    bool isLong;
  }

  struct Action {
    bytes4 selector;
    bytes data;
  }

  IManager public manager;
  bytes32 private _referralCode;

  // Vault variables
  uint256 public constant PRECISION = 1e36;
  uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
  bytes4 constant INCREASE_ACTION = bytes4(
    keccak256("_createIncreasePosition(address,uint256,uint256,uint256,bool)")
  );
  bytes4 constant WITHDRAW_ACTION = bytes4(
    keccak256("_withdraw(address,uint256,bool)")
  );

  uint256 public totalShares;
  mapping (address => uint256) public shares;

  address public indexToken;
  IERC20 public collateralToken;
  IVault public gVault;
  address public gPositionRouter;
  address public gRouter;
  address public gOrderBook;
  address public keeper;
  address public _strategy;
  bool public beenLong;
  uint256 public lookback;
  bytes32 public curPositionKey;     //  current open positionKey
  uint256 public orderIndexCounter;   // sl/tp order index counter
  uint256 public minFund;
  mapping(bytes32 => PositionKeyInfo) public positionKeyInfo;
  Action nextAction;
  bytes sltp;
  
  //  if balance is not enough when withdrawing, `withdraw` function create position.
  //   so withdrawing action can't be done in one transaction. 
  //   register withdraw amount and address to this variable to reference in the callback function
  //   of execute position action called by GMX keeper 
  PositionRequestQueue public queue;
  bool _isLock;
  uint256 _slippage;
  uint256 _leverage;
  uint256 public minEth;

  event GmxPositionCallbackCalled(
    bytes32 requestKey,
    bool isExecuted,
    bool isIncrease
  );

  modifier onlyVault() {
    uint256 vaultId = IPersonalVault(msg.sender).vaultId();
    require(manager.vaultMap(vaultId) == msg.sender, "invalid caller");
    _;
  }

  modifier onlyKeeper() {
    require(msg.sender == keeper || msg.sender == address(manager), "!keeper");
    _;
  }

  // we will lock the contract from the moment we create position to the moment we get the callback from GMX keeper
  modifier lock() {
    require(_isLock == false, "locked");
    _;
  }

  /**
   * @notice
   *  `collateralToken` can be ETH, WETH, BTC, LINK, UNI, USDC, USDT, DAI, FRAX.
   *  if we want another token, need to use external DEX to swap.
   * @param _keeper keeper address
   */
  function initialize(
    address _indexToken,
    address _collateralToken,
    address _manager,
    address _keeper,
    bytes32 _refCode
  ) external payable initializer {
    require(_indexToken != address(0), "zero address");
    indexToken = _indexToken;
    require(_collateralToken != address(0), "zero address");
    collateralToken = IERC20(_collateralToken);
    gVault = IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);
    gRouter = address(0xaBBc5F99639c9B6bCb58544ddf04EFA6802F4064);
    gPositionRouter = address(0xb87a436B93fFE9D75c5cFA7bAcFff96430b09868);
    gOrderBook = address(0x09f77E8A13De9a35a7231028187e9fD5DB8a2ACB);
    keeper = _keeper;
    _referralCode = _refCode;
    lookback = 12;
    _slippage = 30;   // 0.3%
    _leverage = 20_000;
    minFund = gVault.liquidationFeeUsd();
    minEth = 0.001 ether;
    
    require(_manager != address(0), "zero address");
    manager = IManager(_manager);

    //  approve gmx address
    IRouter(gRouter).approvePlugin(gPositionRouter);
    IRouter(gRouter).approvePlugin(gOrderBook);
    collateralToken.safeApprove(gRouter, type(uint256).max);
    collateralToken.safeApprove(gPositionRouter, type(uint256).max);
    collateralToken.safeApprove(gOrderBook, type(uint256).max);
  }

  //  need payable to receive ETH when opening position
  receive() external payable {}

  /**
   * @notice
   *  deposit hypervisor token together with hedge token
   * @param amount amount of hypervisor token
   */
  function deposit(uint256 amount) external onlyVault lock {
    require(amount > 0, "zero amount");
    collateralToken.safeTransferFrom(msg.sender, address(this), amount);
    _issueShares(msg.sender, amount);
  }

  /**
   * @notice
   *  withdraw hypervisor token together with hedge token
   *  if the amount of hedge token, corresponding to hypervisor amount to withdraw, is insufficient, 
   *   create a position request to withdraw hedge token from gmx position and real withdraw action is
   *    done by `gmxPositionCallback` function in the following block.
   * @param amount amount of hypervisor token to withdraw
   */
  function withdraw(uint256 amount) public onlyVault lock returns (bool) {
    return _withdraw(msg.sender, amount);
  }

  /**
   * 
   * @param /*allocation* percent value of how much we put collateral token for position
   * @param isOpen if true, open a position, if false, close a current position
   * @param isLong if true, open a long position, if false, open a short position
   * @param follow_signal if true, update position based on the signal, if false, open position only when there's no active position
   * @param sl stop loss value
   * @param tp take profit value
   */
  function run(uint256 /*allocation*/, bool isOpen, bool isLong, bool follow_signal, uint256 sl, uint256 tp) external lock onlyKeeper payable {
    require(address(this).balance > minEth, "low than minium eth balance");
    (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    
    if (follow_signal == false) {
      if (size == 0) {
        if (isOpen) {
          _createIncreasePosition(0, 0, isLong);
        } else {
          revert("no action needed");
        }
      } else {
        revert("no action needed");
      }
    } else {
      if (size == 0) {
        if (isOpen) {
          require(_isFundIdle() == true, "no enough balance to open position");
          if (sl > 0) {
            sltp = abi.encode(sl, tp);
          }
          _createIncreasePosition(0, 0, isLong);
        } else {
          revert("no action needed");
        }
      } else {
        if (isOpen) {
          if (sl > 0) {
            sltp = abi.encode(sl, tp);
          }
          if (beenLong == isLong) {
            require(_isFundIdle() == true, "no enough balance to open position");
            _createIncreasePosition(0, 0, isLong);
          } else {
            nextAction.selector = INCREASE_ACTION;
            nextAction.data = abi.encode(uint256(0), uint256(0), isLong);
            _createDecreasePosition(0, 0, beenLong);
          }
        } else {
          _createDecreasePosition(0, 0, beenLong);
        }
      }
    }
  }

  function runNextAction() external onlyKeeper {
    if (nextAction.selector == INCREASE_ACTION) {
      (
        uint256 amountIn,
        uint256 sizeDelta,
        bool _isLong
      ) = abi.decode(nextAction.data, (uint256,uint256,bool));
      _createIncreasePosition(amountIn, sizeDelta, _isLong);
      delete nextAction;
    } else if (nextAction.selector == WITHDRAW_ACTION) {
      (
        address recipient,
        uint256 amount
      ) = abi.decode(nextAction.data, (address, uint256));
      _withdraw(recipient, amount);
      delete nextAction;
    } else {
      revert("no next action");
    }
  }

  /**
   * @notice
   *  this function is generally not used because GMX has a keeper and the keeper detects
   *   `createIncreasePosition` action of `PositionRouter` contract and triggers position execution actions.
   *  But GMX docs says keeper may miss orders by accident,
   *   in that case, needs to trigger execution manually.
   */
  function triggerExecutePositionRequest(bytes32 requestKey, bool isOpen) external onlyKeeper {
    // Manual execution is possible `minTimeDelayPublic` seconds later after position created.
    uint256 minTimeDelayPublic = IPositionRouter(gPositionRouter).minTimeDelayPublic();
    if (isOpen) {
      IncreasePositionRequest memory request = IPositionRouter(gPositionRouter).increasePositionRequests(requestKey);
      require(request.blockTime.add(minTimeDelayPublic) <= block.timestamp, "delay");
      IPositionRouter(gPositionRouter).executeIncreasePosition(requestKey, payable(this));
    } else {
      DecreasePositionRequest memory request = IPositionRouter(gPositionRouter).decreasePositionRequests(requestKey);
      require(request.blockTime.add(minTimeDelayPublic) <= block.timestamp, "delay");
      IPositionRouter(gPositionRouter).executeDecreasePosition(requestKey, payable(this));
    }
    _isLock = false;
  }

  /**
   * @notice
   *  this function is a callback of execute position action from GMX Position Router
   *  can be used for several purpose in the future
   */
  function gmxPositionCallback(bytes32 requestKey, bool isExecuted, bool isIncrease) external override {
    require(msg.sender == address(gPositionRouter), "invalid caller");
    require(queue.requestKey == requestKey, "invalid request callback");

    _isLock = false;
    if (isExecuted) {
      if (isIncrease) {
        curPositionKey = keccak256(abi.encodePacked(
          address(this),
          queue.tokenIn,
          queue.indexToken,
          queue.isLong
        ));
        positionKeyInfo[curPositionKey] = PositionKeyInfo(
          queue.tokenIn,
          queue.indexToken,
          queue.isLong
        );
        beenLong = queue.isLong;
        if (sltp.length > 0) {
          (uint256 sl, uint256 tp) = abi.decode(sltp, (uint256, uint256));
          _createDecreaseOrder(sl, !queue.isLong);
          _createDecreaseOrder(tp, queue.isLong);
          delete sltp;
        }
      } else {
        _cancelPendingOrders();
        if (nextAction.selector == INCREASE_ACTION) {
          (
            uint256 amountIn,
            uint256 sizeDelta,
            bool _isLong
          ) = abi.decode(nextAction.data, (uint256,uint256,bool));
          _createIncreasePosition(amountIn, sizeDelta, _isLong);
        } else if (nextAction.selector == WITHDRAW_ACTION) {
          (
            address recipient,
            uint256 amount
          ) = abi.decode(nextAction.data, (address, uint256));
          _withdraw(recipient, amount);
        }
        delete nextAction;
      }
      
    } else {
      delete nextAction;
    }
    
    delete queue;

    emit GmxPositionCallbackCalled(requestKey, isExecuted, isIncrease);
  }

  //////////////////////////////
  ////    View Functions    ////
  //////////////////////////////

  /**
   * @notice
   *  check the description of `_estimatedTotalHedgeAmount`
   */
  function totalAmount() public view returns (uint256) {
    return collateralToken.balanceOf(address(this)) + _estimatedCollateralTokenAmount(curPositionKey);
  }

  function getPositionInfo(bytes32 positionKey) external view returns (PositionInfo memory) {
    (
      uint256 size,
      uint256 collateral,
      uint256 averagePrice,
      uint256 entryFundingRate,
      uint256 reserveAmount,
      int256 realisedPnl,
      uint256 lastIncreasedTime
    ) = gVault.positions(positionKey);
    
    PositionKeyInfo memory pkInfo = positionKeyInfo[positionKey];
    
    return PositionInfo({
      collateralToken: pkInfo.collateralToken,
      indexToken: pkInfo.indexToken,
      isLong: pkInfo.isLong,
      size: size,
      collateral: collateral,
      averagePrice: averagePrice,
      entryFundingRate: entryFundingRate,
      reserveAmount: reserveAmount,
      realisedPnl: realisedPnl > 0 ? uint256(realisedPnl) : uint256(-realisedPnl),
      isPositivePnl: realisedPnl >= 0,
      lastIncreasedTime: lastIncreasedTime
    });
  }

  function isNextAction() external view returns (bool) {
    if (nextAction.selector.length == 0 && sltp.length == 0)  {
      return false;
    } else {
      return true;
    }
  }

  function referralCode() external view returns (bytes32) {
    return _referralCode;
  }

  function isLock() external view returns (bool) {
    return _isLock;
  }

  function slippage() external view returns (uint256) {
    return _slippage;
  }

  function strategy() external view returns (address) {
    return _strategy;
  }

  function migrateStrategy() external onlyKeeper {}

  function setLock(bool locked) external onlyKeeper {
    _isLock = locked;
  }

  function setSlippage(uint256 val) external onlyKeeper {
    _slippage = val;
  }

  function setLeverageValue(uint256 val) external onlyKeeper {
    require(val > BASIS_POINTS_DIVISOR, "low than minimum");
    require(val < gVault.maxLeverage(), "exceed maximum value");
    _leverage = val;
  }

  function setLookbackPeriod(uint256 _lookback) external onlyKeeper {
    lookback = _lookback;
  }

  function setMinFund(uint256 _minFund) external onlyKeeper {
    require(minFund >= gVault.liquidationFeeUsd(), "minimum");
    minFund = _minFund;
  }

  function setMinEth(uint256 _minEth) external onlyKeeper {
    require(minEth > 0, "minimum");
    minFund = _minEth;
  }
  
  //////////////////////////////
  ////  Internal Functions  ////
  //////////////////////////////

  function _issueShares(address to, uint256 amount) internal {
    uint256 _shares = 0;
    if (totalShares > 0) {
      _shares = amount * totalShares / totalAmount();
    } else {
      _shares = amount;
    }

    shares[to] = _shares;
    totalShares = totalShares + _shares;
  }

  function _isFundIdle() internal view returns (bool) {
    uint256 balance = collateralToken.balanceOf(address(this));
    if (gVault.tokenToUsdMin(address(collateralToken), balance) > minFund) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @notice
   *  create increase position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't open position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param amountIn: the amount of tokenIn you want to deposit as collateral
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createIncreasePosition(
    uint256 amountIn,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    // `_tokenIn` should be `indexToken` when long position, and stable coin when short position.
    address _tokenIn;
    if (_isLong == true) {
      _tokenIn = indexToken;
    } else {
      _tokenIn = address(collateralToken);
    }
    uint256 fee = IPositionRouter(gPositionRouter).minExecutionFee();
    require(address(this).balance >= fee, "too low execution fee");
    // require(
    //   sizeDelta > gVault.tokenToUsdMin(address(collateralToken), amountIn),
    //   "too low leverage"
    // );
    // require(
    //   sizeDelta.div(gVault.tokenToUsdMin(address(collateralToken), amountIn)) < gVault.maxLeverage().div(BASIS_POINTS_DIVISOR),
    //   "exceed max leverage"
    // );
    // check available amounts to open positions
    if (amountIn == 0) {
      amountIn = collateralToken.balanceOf(address(this));
    }
    if (sizeDelta == 0) {
      sizeDelta = gVault.tokenToUsdMin(address(collateralToken), amountIn) * _leverage / BASIS_POINTS_DIVISOR;
    }

    console.log("amountIn is %s", amountIn);
    console.log("sizeDelta is %s", sizeDelta);
    
    _checkPool(_isLong, indexToken, _tokenIn, sizeDelta);

    (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    if (size == 0) {
      // did balance check basically in the prior function but need to do again here 
      //  against the current gmx min value to avoid potential gmx side transaction failure.
      require(sizeDelta > vaultMinUsd(), "insufficient amount to open position");
    }
    
    address[] memory path = _getPath(_tokenIn, true);
    uint256 acceptablePrice = _isLong ? 
      gVault.getMaxPrice(indexToken).mul(BASIS_POINTS_DIVISOR + _slippage).div(BASIS_POINTS_DIVISOR) :
      gVault.getMinPrice(indexToken).mul(BASIS_POINTS_DIVISOR - _slippage).div(BASIS_POINTS_DIVISOR);
    console.log("tokenIn is %s", _tokenIn);
    console.log("isLong is %s", _isLong);
    bytes32 requestKey = IPositionRouter(gPositionRouter).createIncreasePosition{value: fee}(
      path,
      indexToken,
      amountIn,
      0,       // it's better to provide minimum output token amount from a caller rather than calculate here
      sizeDelta,    // we can set sizeDelta based on leverage value. need to decide which one is preferred
      _isLong,
      acceptablePrice,   // current ETH mark price
      fee,
      _referralCode,
      address(this)
    );
    console.log("here");

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;
    queue.tokenIn = _tokenIn;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  /**
   * @notice
   *  create decrease position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't close position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralDelta: the amount of collateral in USD value to withdraw
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createDecreasePosition(
    uint256 collateralDelta,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    // `_tokenIn` should be `indexToken` when long position, and stable coin when short position.
    address _tokenIn;
    if (_isLong == true) {
      _tokenIn = indexToken;
    } else {
      _tokenIn = address(collateralToken);
    }
    uint256 fee = IPositionRouter(gPositionRouter).minExecutionFee();
    require(address(this).balance >= fee, "too low execution fee");

    (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    if (
      sizeDelta == 0 ||
      size - sizeDelta < vaultMinUsd()
    ) {
      sizeDelta = size;
    }

    _checkPool(_isLong, indexToken, _tokenIn, sizeDelta);
    address[] memory path = _getPath(_tokenIn, false);
    
    uint256 acceptablePrice = _isLong ?
      gVault.getMinPrice(indexToken).mul(BASIS_POINTS_DIVISOR - _slippage).div(BASIS_POINTS_DIVISOR) :
      gVault.getMaxPrice(indexToken).mul(BASIS_POINTS_DIVISOR + _slippage).div(BASIS_POINTS_DIVISOR);
    bytes32 requestKey = IPositionRouter(gPositionRouter).createDecreasePosition{value: fee}(
      path,
      indexToken,
      collateralDelta,
      sizeDelta,
      _isLong,
      address(this),
      acceptablePrice,
      0,
      fee,
      false,
      address(this)
    );

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;
    queue.tokenIn = _tokenIn;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  function _createDecreaseOrder(
    uint256 _triggerPrice,
    bool _triggerAboveThreshold
  ) internal {
    (uint256 _sizeDelta, , , , , , ) = gVault.positions(curPositionKey);
    address _tokenIn;
    if (beenLong == true) {
      _tokenIn = indexToken;
    } else {
      _tokenIn = address(collateralToken);
    }

    uint256 fee = IOrderBook(gOrderBook).minExecutionFee();
    require(address(this).balance >= fee, "too low execution fee");
    IOrderBook(gOrderBook).createDecreaseOrder{value: fee + 1}(
      indexToken,
      _sizeDelta,
      _tokenIn,
      0,
      beenLong,
      _triggerPrice,
      _triggerAboveThreshold
    );
    orderIndexCounter = orderIndexCounter + 1;
  }

  // cancel all orders when switching positions
  function _cancelPendingOrders() internal {
    uint256 _orderIndex = IOrderBook(gOrderBook).decreaseOrdersIndex(address(this));
    (, , , , , uint256 triggerPrice0, , ) = IOrderBook(gOrderBook).getDecreaseOrder(address(this), _orderIndex - 1);
    (, , , , , uint256 triggerPrice1, , ) = IOrderBook(gOrderBook).getDecreaseOrder(address(this), _orderIndex - 2);
    if (triggerPrice0 > 0) {
      IOrderBook(gOrderBook).cancelDecreaseOrder(_orderIndex - 1);
    }
    if (triggerPrice1 > 0) {
      IOrderBook(gOrderBook).cancelDecreaseOrder(_orderIndex - 2);
    }
  }

  function _withdraw(address recipient, uint256 _shares) internal returns (bool) {
    require(_shares != 0, "zero amount");
    require(_shares <= shares[recipient], "exceed due");
    // get amount to withdraw from the estimated total hedgeAmount(balance + GMX liquidity)
    uint256 amount = totalAmount() * _shares / totalShares;
    uint256 balance = collateralToken.balanceOf(address(this));
    if (balance >= amount) {
      collateralToken.safeTransfer(recipient, amount);
      balance = balance.sub(amount);
      return true;
    }

    // if we don't have enough balance, need to withdraw from GMX
    //  when decreasing position, we can't indicate amount of collateral token to withdraw using collateralDelta
    //   because `swapFee` and `closeFee` would be deducted from `amountOut`. it may need to multiply 1.01. should check exact multiplier value via testing
    uint256 want = amount.sub(balance).mul(10100).div(BASIS_POINTS_DIVISOR);
          
    (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    
    PositionKeyInfo memory pkInfo = positionKeyInfo[curPositionKey];

    uint256 estimatedHedgeAmount = _estimatedCollateralTokenAmount(curPositionKey);
    uint256 sizeDelta;
    uint256 collateralDelta;
    if (want > estimatedHedgeAmount) {
      sizeDelta = size;
      collateralDelta = gVault.tokenToUsdMin(address(collateralToken), estimatedHedgeAmount);      // can be set as 0
    } else {
      //  may need to consider fee deduction
      sizeDelta = want.mul(size).div(estimatedHedgeAmount);   //  want * size / netValue
      collateralDelta = gVault.tokenToUsdMin(address(collateralToken), want);          // can be set as 0
    }

    nextAction.selector = WITHDRAW_ACTION;
    nextAction.data = abi.encode(msg.sender, amount, true);
    _createDecreasePosition(collateralDelta, sizeDelta, pkInfo.isLong);
    return false;
  }

  /**
   * @notice
   *  check available liquidity before create positions
   */
  function _checkPool(bool _isLong, address _indexToken, address _tokenIn, uint256 sizeDelta) internal view {
    uint256 availableTokens = gVault.poolAmounts(_tokenIn).sub(gVault.reservedAmounts(_tokenIn));
    require(sizeDelta < gVault.tokenToUsdMin(_tokenIn, availableTokens), "max longs / shorts exceeded");
    
    if (_isLong) {
      uint256 maxGlobalLongSize = IPositionRouter(gPositionRouter).maxGlobalLongSizes(_indexToken);
      if (maxGlobalLongSize != 0) {
        require(
          gVault.guaranteedUsd(_indexToken).add(sizeDelta) < maxGlobalLongSize,
          "max longs exceeded"
        );
      }
    } else {
      uint256 maxGlobalShortSize = IPositionRouter(gPositionRouter).maxGlobalShortSizes(_indexToken);
      if (maxGlobalShortSize != 0) {
        require(
          gVault.globalShortSizes(_indexToken).add(sizeDelta) < maxGlobalShortSize,
          "max shorts exceeded"
        );
      }
    } 
  }

  function vaultMinUsd() internal view returns (uint256) {
    return gVault.liquidationFeeUsd() * _leverage / BASIS_POINTS_DIVISOR;
  }

  /**
   * @notice
   *  `openFee` is deducted when opening position. openFee = sizeDelta * 0.1%
   *  `closeFee` is deducted when closing position. closeFee = sizeDelta * 0.1%
   *  `borrowFee` is deducted when position size change. borrowFee = size * fundingRate. reset to 0 whenever position change.
   *  `swapFee` is deducted when swapping `collateralToken` to `tokenOut`==`collateralToken`.
   *    we will ignore `swapFee` when estimating hedge token amount
   */
  function _estimatedCollateralTokenAmount(bytes32 positionKey) internal view returns (uint256) {
    (uint256 size, uint256 collateral, , uint256 entryFundingRate, , , ) = gVault.positions(positionKey);
    if (size == 0) return 0;
    (bool hasProfit, uint256 delta) = gVault.getPositionDelta(
      address(this),
      positionKeyInfo[positionKey].collateralToken,
      positionKeyInfo[positionKey].indexToken,
      positionKeyInfo[positionKey].isLong
    );

    uint256 cumulativeFundingRate = gVault.cumulativeFundingRates(positionKeyInfo[positionKey].collateralToken);
    uint256 borrowFee = size.mul(cumulativeFundingRate.sub(entryFundingRate).div(1e6));       // gVault.getFundingFee()
    uint256 closeFee = size.mul(gVault.marginFeeBasisPoints()).div(BASIS_POINTS_DIVISOR);   // gVault.getPositionFee()
    // uint256 swapFee = positionKeyInfo[positionKey].collateralToken == address(collateralToken) ? 0 : ;
    uint256 netValue;
    if (hasProfit) {
      netValue = collateral.add(delta).sub(borrowFee).sub(closeFee);
    } else {
      netValue = collateral.sub(delta).sub(borrowFee).sub(closeFee);
    }
    
    uint256 amount = gVault.usdToTokenMin(address(collateralToken), netValue);

    return amount;
  }

  function _getPath(address _tokenIn, bool isIncrease) private view returns (address[] memory) {
    address[] memory path;
    if (address(collateralToken) == _tokenIn) {
      path = new address[](1);
      path[0] = address(collateralToken);
    } else {
      path = new address[](2);
      if (isIncrease) {
        path[0] = address(collateralToken);
        path[1] = _tokenIn;
      } else {
        path[0] = _tokenIn;
        path[1] = address(collateralToken);
      }
    }
    return path;
  }

}

