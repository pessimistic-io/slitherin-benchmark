// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.4;
pragma abicoder v2;

import "./IERC20.sol";
import "./SafeERC20.sol";
import "./Ownable2StepUpgradeable.sol";
import "./ReentrancyGuardUpgradeable.sol";
import "./IPersonalVault.sol";
import "./IManager.sol";
import "./IDataStore.sol";
import "./IVault.sol";
import "./IReader.sol";
import "./IExchangeRouter.sol";
import "./IGmxUtils.sol";
import "./IUniversalRouter.sol";

import "./console.sol";

/**
 * @notice
 *  need to restrict the vault to have only 1 open position at the same time, if not, difficult to manage positions because of async operations
 */
contract PerpetualVault is Initializable, ReentrancyGuardUpgradeable, Ownable2StepUpgradeable {
  using SafeERC20 for IERC20;

  struct PositionRequestQueue {
    bytes32 requestKey;                 //  requestKey generated by PositionRouter contract of GMX
    address tokenIn;
    address indexToken;
    bool isLong;
  }

  struct Action {
    bytes4 selector;
    bytes data;
  }

  string public name;
  IManager public manager;
  bytes32 private _referralCode;

  // Vault variables
  uint256 public constant PRECISION = 1e30;
  uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
  bytes1 constant INCREASE_ACTION = bytes1(0x01);
  bytes1 constant DECREASE_WITHDRAW_ACTION = bytes1(0x02);
  bytes1 constant CREATE_DECREASE_ORDER = bytes1(0x03);
  bytes1 constant WITHDRAW_ACTION = bytes1(0x04);

  uint256 public totalShares;
  mapping (address => uint256) public shares;
  mapping (address => uint256) public initialDeposit;

  address public market;
  address public indexToken;
  IERC20 public collateralToken;
  IExchangeRouter public gExchangeRouter;
  IReader public gReader;
  IGmxUtils public gmxUtils;
  address public gDataStore;
  IUniversalRouter public universalRouter;
  
  address public keeper;
  address public _strategy;
  bool public beenLong;
  bytes32 public curPositionKey;     //  current open positionKey
  uint256 public minFund;             // 30 decimals
  uint256 public minCollateralUsd;             // 30 decimals
  bool public closed;
  uint256 public minEth;
  uint256 public governanceFee;
  uint256 public callbackGasLimit;
  //  if balance is not enough when withdrawing, `withdraw` function create position.
  //   so withdrawing action can't be done in one transaction. 
  //   register withdraw amount and address to this variable to reference in the callback function
  //   of execute position action called by GMX keeper 
  PositionRequestQueue public queue;
  
  Action nextAction;
  bytes sltp;
  bool _isLock;
  uint256 _slippage;
  uint256 _leverage;
  uint256 _gasBufferFactor;
  bytes[] swapData;
  MarketPrices marketPrices;

  event GmxPositionCallbackCalled(
    bytes32 requestKey,
    bool isIncrease
  );

  modifier onlyVault() {
    uint256 vaultId = IPersonalVault(msg.sender).vaultId();
    require(manager.vaultMap(vaultId) == msg.sender, "invalid caller");
    _;
  }

  modifier onlyKeeper() {
    require(msg.sender == keeper || msg.sender == address(manager), "!keeper");
    _;
  }

  // we will lock the contract from the moment we create position to the moment we get the callback from GMX keeper
  modifier lock() {
    require(_isLock == false, "locked");
    _;
  }

  /**
   * @notice
   *  `collateralToken` can be ETH, WETH, BTC, LINK, UNI, USDC, USDT, DAI, FRAX.
   *  if we want another token, need to use external DEX to swap.
   * @param _keeper keeper address
   */
  function initialize(
    string memory _name,
    address _market,
    address _collateralToken,
    address _manager,
    address _keeper,
    address _gmxUtils,
    bytes32 _refCode
  ) external initializer {
    __Ownable2Step_init();
    name = _name;
    require(_market != address(0), "zero address");
    require(_collateralToken != address(0), "zero address");
    require(_gmxUtils != address(0), "zero address");
    market = _market;
    collateralToken = IERC20(_collateralToken);
    gExchangeRouter = IExchangeRouter(0x7C68C7866A64FA2160F78EEaE12217FFbf871fa8);
    gReader = IReader(0xf60becbba223EEA9495Da3f606753867eC10d139);
    gDataStore = address(0xFD70de6b91282D8017aA4E741e9Ae325CAb992d8);
    gmxUtils = IGmxUtils(_gmxUtils);
    gmxUtils.setEnvVars(address(this), _manager);
    // gVault = IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);
    universalRouter = IUniversalRouter(0xeC8B0F7Ffe3ae75d7FfAb09429e3675bb63503e4);
    MarketProps memory marketInfo = gReader.getMarket(gDataStore, market);
    indexToken = marketInfo.indexToken;
    keeper = _keeper;
    _referralCode = _refCode;
    governanceFee = 500;  // 5%
    _slippage = 30;   // 0.3%
    _leverage = 20_000;
    _gasBufferFactor = 12_000;
    minCollateralUsd = 10 * PRECISION;
    minEth = 0.002 ether;
    callbackGasLimit = 2_000_000;
    
    require(_manager != address(0), "zero address");
    manager = IManager(_manager);

    //  approve gmx router address
    // collateralToken.safeApprove(address(0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6), type(uint256).max);
    // approve `collateralToken` and `indexToken` on `PERMIT2` contract of uniswap v3
    collateralToken.safeApprove(address(0x000000000022D473030F116dDEE9F6B43aC78BA3), type(uint256).max);
    IERC20(indexToken).safeApprove(address(0x000000000022D473030F116dDEE9F6B43aC78BA3), type(uint256).max);
  }

  //  need payable to receive ETH when opening position
  receive() external payable {}

  /**
   * @notice
   *  deposit hypervisor token together with hedge token
   * @param amount amount of hypervisor token
   */
  function deposit(uint256 amount) external onlyVault nonReentrant lock {
    require(amount > 0, "zero amount");
    collateralToken.safeTransferFrom(msg.sender, address(this), amount);
    _issueShares(msg.sender, amount, true);
  }

  /**
   * @notice
   *  withdraw hypervisor token together with hedge token
   *  if the amount of hedge token, corresponding to hypervisor amount to withdraw, is insufficient, 
   *   create a position request to withdraw hedge token from gmx position and real withdraw action is
   *    done by `gmxPositionCallback` function in the following block.
   * @param _shares share amount of hedge token to withdraw
   */
  function withdraw(address recipient, uint256 _shares) public onlyVault nonReentrant lock returns (bool) {
    require(address(gmxUtils).balance > minEth, "low than minium eth balance");
    require(recipient != address(0), "zero address");
    require(_shares != 0, "zero amount");
    require(_shares <= shares[msg.sender], "exceed due");
    require(nextAction.selector != WITHDRAW_ACTION, "withdrawal is in progress");
    uint256 amount = totalAmount() * _shares / totalShares;
    return _withdraw(msg.sender, recipient, _shares, amount, false);
  }

  /**
   * 
   * @param isOpen if true, open a position, if false, close a current position
   * @param isLong if true, open a long position, if false, open a short position
   * @param sl stop loss value. its decimals is 30
   * @param tp take profit value. its decimals is 30
   */
  function run(bool isOpen, bool isLong, uint256 sl, uint256 tp, MarketPrices memory prices, bytes[] memory _swapData) external lock onlyKeeper {
    require(address(gmxUtils).balance > minEth, "low than minium eth balance");
    uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);
    marketPrices = prices;
    swapData = _swapData;

    if (isOpen) {
      closed = false;
      if (sizeInUsd == 0) {
        require(_isFundIdle() == true, "no enough balance to open position");
        sltp = abi.encode(sl, tp);
        _createIncreasePosition(0, 0, isLong);
      } else {
        if (beenLong == isLong) {
          _cancelPendingOrders();
          _createDecreaseOrder(sl, tp);
        } else {
          sltp = abi.encode(sl, tp);
          nextAction.selector = INCREASE_ACTION;
          nextAction.data = abi.encode(uint256(0), uint256(0), isLong);
          _createDecreasePosition(0, 0, beenLong);
        }
      }
    } else {
      closed = true;
      if (sizeInUsd > 0) {
        _createDecreasePosition(0, 0, beenLong);
      } else {
        revert("no action needed");
      }
    }
  }

  function runNextAction(MarketPrices memory prices, bytes[] memory _swapData) external lock onlyKeeper {
    marketPrices = prices;
    swapData = _swapData;
    if (nextAction.selector == INCREASE_ACTION) {
      (
        uint256 amountIn,
        uint256 sizeDelta,
        bool _isLong
      ) = abi.decode(nextAction.data, (uint256,uint256,bool));
      _createIncreasePosition(amountIn, sizeDelta, _isLong);
      delete nextAction;
    } else if (nextAction.selector == DECREASE_WITHDRAW_ACTION) {
      (
        uint256 collateralDelta,
        uint256 sizeDelta,
        bool _isLong,
        bytes memory withdrawData
      ) = abi.decode(nextAction.data, (uint256, uint256, bool, bytes));
      nextAction.selector = WITHDRAW_ACTION;
      nextAction.data = withdrawData;
      _createDecreasePosition(collateralDelta, sizeDelta, _isLong);
    } else if (nextAction.selector == CREATE_DECREASE_ORDER) {
      _cancelPendingOrders();
      (uint256 sl, uint256 tp) = abi.decode(sltp, (uint256, uint256));
      _createDecreaseOrder(sl, tp);
      delete sltp;
      delete nextAction;
    } else if (nextAction.selector == WITHDRAW_ACTION) {
      (
        address to,
        address recipient,
        uint256 _shares
      ) = abi.decode(nextAction.data, (address, address, uint256));
      _withdraw(to, recipient, _shares, 0, true);
      if (curPositionKey.length > 0) {
        (uint256 sl, uint256 tp) = abi.decode(sltp, (uint256, uint256));
        _createDecreaseOrder(sl, tp);
      }
      delete nextAction;
    } else if (closed == false && _isFundIdle()) {
      _createIncreasePosition(0, 0, beenLong);
      // sl/tp adjustment needed because position size was changed
      (uint256 sl, uint256 tp) = _cancelPendingOrders();
      sltp = abi.encode(sl, tp);
    } else {
      revert("no next action");
    }
  }

  // /**
  //  * @notice
  //  *  this function is generally not used because GMX has a keeper and the keeper detects
  //  *   `createIncreasePosition` action of `PositionRouter` contract and triggers position execution actions.
  //  *  But GMX docs says keeper may miss orders by accident,
  //  *   in that case, needs to trigger execution manually.
  //  */

  function afterOrderExecution(bytes32 key, IGmxUtils.OrderType orderType, bool isLong, bytes32 positionKey) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    require(queue.requestKey == key, "invalid request callback");
    
    _isLock = false;
    // uint256 sl;
    // uint256 tp;
    if (orderType == IGmxUtils.OrderType.MarketIncrease) {
      curPositionKey = positionKey;
      beenLong = isLong;
      // _cancelPendingOrders();
      // (sl, tp) = abi.decode(sltp, (uint256, uint256));
      // _createDecreaseOrder(sl, tp);
      // delete sltp;
      nextAction.selector = CREATE_DECREASE_ORDER;
    } else if(orderType == IGmxUtils.OrderType.MarketDecrease) {
      uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);
      (uint256 sl, uint256 tp) = _cancelPendingOrders();
      if (sizeInUsd > 0) {
        // _createDecreaseOrder(sl, tp);   // create decrease orders with the updated size data
        sltp = abi.encode(sl, tp);
        // nextAction.selector = CREATE_DECREASE_ORDER;
      } else {
        // closed = true;
        curPositionKey = hex'';
      }
    }
    delete queue;
    emit GmxPositionCallbackCalled(key, true);
  }

  function afterOrderCancellation(bytes32 key, IGmxUtils.OrderType, bool, bytes32) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    _isLock = false;
    delete nextAction;
    emit GmxPositionCallbackCalled(key, false);
  }

  function afterOrderFrozen(bytes32 key, IGmxUtils.OrderType, bool, bytes32) external {}

  //////////////////////////////
  ////    View Functions    ////
  //////////////////////////////

  /**
   * @notice
   *  check the description of `_estimatedTotalHedgeAmount`
   */
  function totalAmount() public view returns (uint256) {
    if (curPositionKey == bytes32(0)) {
      return collateralToken.balanceOf(address(this));
    }
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
    return collateralToken.balanceOf(address(this)) + positionData.netValueInCollateralToken;
  }

  function getPositionInfo() external view returns (address, address, uint256, uint256,uint256, uint256, bool) {
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
    return (
      market,
      address(collateralToken),
      positionData.sizeInUsd,
      positionData.sizeInTokens,
      positionData.collateralAmount,
      positionData.netValueInCollateralToken,
      positionData.isLong
    );
  }

  function isNextAction() external view returns (bool) {
    // (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    if (_isLock == true ) {
      return false;
    } else if (nextAction.selector != bytes4(0) || (_isFundIdle() && closed == false)) {
      return true;
    } else {
      return false;
    }
  }

  function isWithdrawing() external view returns (bool) {
    return nextAction.selector == WITHDRAW_ACTION;
  }

  function referralCode() external view returns (bytes32) {
    return _referralCode;
  }

  function isLock() external view returns (bool) {
    return _isLock;
  }

  function slippage() external view returns (uint256) {
    return _slippage;
  }

  function strategy() external view returns (address) {
    return _strategy;
  }

  function setKeeper(address _keeper) external onlyOwner {
    require(_keeper != address(0), "zero address");
    keeper = _keeper;
  }

  function setGmxUtils(address _gmxUtils) external onlyOwner {
    require(_gmxUtils != address(0), "zero address");
    uint256 amount;
    if (address(gmxUtils) != address(0)) {
      amount = gmxUtils.withdrawEth();
    }
    gmxUtils = IGmxUtils(_gmxUtils);
    gmxUtils.setEnvVars(address(this), address(manager));
    if (amount > 0) {
      payable(_gmxUtils).transfer(amount);
    }    
  }

  function setLock(bool locked) external onlyOwner {
    _isLock = locked;
  }

  function setSlippage(uint256 val) external onlyOwner {
    _slippage = val;
  }

  function setLeverageValue(uint256 val) external onlyOwner {
    require(val > BASIS_POINTS_DIVISOR, "low than minimum");
    _leverage = val;
  }

  function setMinFund(uint256 _minFund) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minFund >= min, "minimum");
    minFund = _minFund;
  }

  function setMinCollateralUsd(uint256 _minCollateralUsd) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minCollateralUsd > min, "minimum");
    minCollateralUsd = _minCollateralUsd;
  }

  function setMinEth(uint256 _minEth) external onlyOwner {
    require(_minEth > 0, "minimum");
    minEth = _minEth;
  }

  function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {
    require(_callbackGasLimit > 0, "zero value");
    callbackGasLimit = _callbackGasLimit;
  }
  
  //////////////////////////////
  ////  Internal Functions  ////
  //////////////////////////////

  function _issueShares(address to, uint256 amount, bool isMint) internal {
    if (isMint) {
      uint256 _shares = 0;
      if (totalShares > 0) {
        _shares = amount * totalShares / totalAmount();
      } else {
        _shares = amount;
      }

      shares[to] = shares[to] + _shares;
      totalShares = totalShares + _shares;
    } else {
      shares[to] = shares[to] - amount;
      totalShares = totalShares - amount;
    }
  }

  function _isFundIdle() internal view returns (bool) {
    uint256 balance = collateralToken.balanceOf(address(this));
    if (gmxUtils.tokenToUsdMin(address(collateralToken), balance) > minFund) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @notice
   *  create increase position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't open position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param amountIn: the amount of tokenIn you want to deposit as collateral
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createIncreasePosition(
    uint256 amountIn,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    bytes32 requestKey;
    // check available amounts to open positions
    if (amountIn == 0) {
      amountIn = collateralToken.balanceOf(address(this));
    }
    IGmxUtils.OrderType orderType;
    if (_isLong) {
      for (uint8 i = 0; i < swapData.length; i++) {
        (PROTOCOL _protocol, bytes memory data) = abi.decode(swapData[i], (PROTOCOL, bytes));
        if (_protocol == PROTOCOL.UNISWAP) {
          (address to, bytes memory callData) = abi.decode(
            data,
            (address, bytes)
          );
          (bool success, ) = to.call(callData);
          require(success, "uniswap call reverted");
          // universalRouter.execute(commands, inputs, deadline);
        } else {
          (address[] memory gPath) = abi.decode(data, (address[]));
          orderType = IGmxUtils.OrderType.MarketSwap;
          amountIn = collateralToken.balanceOf(address(this));
          collateralToken.safeTransfer(address(gmxUtils), amountIn);
          IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
            market: address(0),
            indexToken: address(0),
            initialCollateralToken: address(collateralToken),
            swapPath: gPath,
            isLong: _isLong,
            sizeDeltaUsd: 0,
            initialCollateralDeltaAmount: 0,
            amountIn: amountIn,
            callbackGasLimit: callbackGasLimit
          });
          requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
        }
      }
    } else {
      address[] memory swapPath;
      orderType = IGmxUtils.OrderType.MarketIncrease;
      collateralToken.safeTransfer(address(gmxUtils), amountIn);
      if (sizeDelta == 0) {
        sizeDelta = marketPrices.shortTokenPrice.max * amountIn * _leverage / BASIS_POINTS_DIVISOR;
      }
      IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
        market: market,
        indexToken: indexToken,
        initialCollateralToken: address(collateralToken),
        swapPath: swapPath,
        isLong: _isLong,
        sizeDeltaUsd: sizeDelta,
        initialCollateralDeltaAmount: 0,
        amountIn: amountIn,
        callbackGasLimit: callbackGasLimit 
      });
      requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
    }

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  /**
   * @notice
   *  create decrease position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't close position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralDelta: the amount of collateral in USD value to withdraw
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createDecreasePosition(
    uint256 collateralDelta,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    bytes32 requestKey;
    address[] memory swapPath;
    IGmxUtils.OrderType orderType;
    if (beenLong) {
      for (uint8 i = 0; i < swapData.length; i++) {
        (PROTOCOL _protocol, bytes memory data) = abi.decode(swapData[i], (PROTOCOL, bytes));
        if (_protocol == PROTOCOL.UNISWAP) {
          (address to, bytes memory callData) = abi.decode(
            data,
            (address, bytes)
          );
          (bool success, ) = to.call(callData);
          require(success, "uniswap call reverted");
          // universalRouter.execute(commands, inputs, deadline);
        } else {
          (address[] memory gPath, uint256 amountIn) = abi.decode(data, (address[], uint256));
          orderType = IGmxUtils.OrderType.MarketSwap;
          IERC20(indexToken).safeTransfer(address(gmxUtils), amountIn);
          IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
            market: address(0),
            indexToken: address(0),
            initialCollateralToken: address(collateralToken),
            swapPath: gPath,
            isLong: _isLong,
            sizeDeltaUsd: 0,
            initialCollateralDeltaAmount: 0,
            amountIn: amountIn,
            callbackGasLimit: callbackGasLimit 
          });
          requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
        }
      }
    } else {
      orderType = IGmxUtils.OrderType.MarketDecrease;
      uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);
      if (
        sizeDelta == 0 ||
        sizeInUsd - sizeDelta < minCollateralUsd     // suppose we don't do above 1.1x leverage. so size is nearly the same as collateral amount
      ) {
        sizeDelta = sizeInUsd;
      }
      IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
        market: market,
        indexToken: indexToken,
        initialCollateralToken: address(collateralToken),
        swapPath: swapPath,
        isLong: _isLong,
        sizeDeltaUsd: sizeDelta,
        initialCollateralDeltaAmount: collateralDelta,
        amountIn: 0,
        callbackGasLimit: callbackGasLimit
      });
      requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
    }

    //  update state variables
    _isLock = true;
    queue.requestKey = requestKey;

  }

  function _createDecreaseOrder(uint256 sl, uint256 tp) internal {
    gmxUtils.createDecreaseOrder(curPositionKey, market, beenLong, sl, tp, callbackGasLimit, marketPrices);
  }

  // cancel all orders when switching positions
  function _cancelPendingOrders() internal returns (uint256 sl, uint256 tp) {
    Order.Props[] memory orders = gReader.getAccountOrders(gDataStore, address(this), 0, 1);
    if (orders.length == 0) return (0, 0);
    if (orders.length == 2) {
      if (orders[0].numbers.orderType == Order.OrderType.LimitDecrease) {
        sl = orders[1].numbers.triggerPrice;
        tp = orders[0].numbers.triggerPrice;
      } else {
        sl = orders[0].numbers.triggerPrice;
        tp = orders[1].numbers.triggerPrice;
      }
    }
    
    bytes32 accountOrderListKey = keccak256(abi.encode(keccak256(abi.encode("ACCOUNT_ORDER_LIST")), address(this)));
    bytes32[] memory orderKeys = IDataStore(gDataStore).getBytes32ValuesAt(accountOrderListKey, 0, 10);
    for (uint8 i = 0; i < orderKeys.length; ) {
      gExchangeRouter.cancelOrder(orderKeys[i]);
      unchecked{
        i = i + 1;
      }
    }
    return (sl, tp);
  }

  function _withdraw(address to, address recipient, uint256 _shares, uint256 amount, bool forced) internal returns (bool) {
    // get amount to withdraw from the estimated total hedgeAmount(balance + GMX liquidity)
    if (forced == false) {
      amount = totalAmount() * _shares / totalShares;
    }
    uint256 balance = collateralToken.balanceOf(address(this));
    if (forced || balance >= amount ) {
      if (amount > initialDeposit[to]) {
        uint256 fee = (amount - initialDeposit[to]) * governanceFee / BASIS_POINTS_DIVISOR;
        collateralToken.safeTransfer(manager.treasury(), fee);
        collateralToken.safeTransfer(recipient, amount - fee);
      } else {
        collateralToken.safeTransfer(recipient, amount);
      }
      
      balance = balance - amount;
      _issueShares(to, _shares, false);
      return true;
    }

    // if we don't have enough balance, need to withdraw from GMX
    //  when decreasing position, we can't indicate amount of collateral token to withdraw using collateralDelta
    //   because `swapFee` and `closeFee` would be deducted from `amountOut`. it may need to multiply 1.01. should check exact multiplier value via testing
    uint256 want = amount - balance;
          
    // (uint256 size, , , , , , ) = gVault.positions(curPositionKey);
    // uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);

    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
    uint256 sizeDelta;
    uint256 collateralDelta;
    if (want > positionData.netValueInCollateralToken) {
      sizeDelta = positionData.sizeInUsd;
      collateralDelta = marketPrices.shortTokenPrice.max * positionData.netValueInCollateralToken;
      // gmxUtils.tokenToUsdMin(address(collateralToken), positionData.netValueInCollateralToken);      // can be set as 0
    } else {
      //  may need to consider fee deduction
      sizeDelta = want * positionData.sizeInUsd / positionData.netValueInCollateralToken;   //  want * size / netValue
      collateralDelta = marketPrices.shortTokenPrice.max * want;
      // gmxUtils.tokenToUsdMin(address(collateralToken), want);          // can be set as 0
    }

    nextAction.selector = DECREASE_WITHDRAW_ACTION;
    bytes memory withdrawActionData = abi.encode(to, recipient, _shares, amount);
    nextAction.data = abi.encode(collateralDelta, sizeDelta, beenLong, withdrawActionData);
    return false;

    // nextAction.selector = WITHDRAW_ACTION;
    // nextAction.data = abi.encode(to, recipient, _shares);
    // _createDecreasePosition(collateralDelta, sizeDelta, beenLong);
    // return false;
  }

  // this is a temporary function for development
  function withdraw(address token) external onlyOwner {
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(msg.sender, balance);
  }

  /**
   * @notice
   *  check available liquidity before create positions
   */
  // function _checkPool(bool _isLong, address _indexToken, address _tokenIn, uint256 sizeDelta) internal view {
  //   uint256 maxReservedUsd = getMaxReservedUsd(market, isLong);
  //   uint256 availableTokens = gVault.poolAmounts(_tokenIn) - gVault.reservedAmounts(_tokenIn);
  //   require(sizeDelta < gVault.tokenToUsdMin(_tokenIn, availableTokens), "max longs / shorts exceeded");
    
  //   if (_isLong) {
  //     uint256 maxGlobalLongSize = IPositionRouter(gPositionRouter).maxGlobalLongSizes(_indexToken);
  //     if (maxGlobalLongSize != 0) {
  //       require(
  //         gVault.guaranteedUsd(_indexToken) + sizeDelta < maxGlobalLongSize,
  //         "max longs exceeded"
  //       );
  //     }
  //   } else {
  //     uint256 maxGlobalShortSize = IPositionRouter(gPositionRouter).maxGlobalShortSizes(_indexToken);
  //     if (maxGlobalShortSize != 0) {
  //       require(
  //         gVault.globalShortSizes(_indexToken) + sizeDelta < maxGlobalShortSize,
  //         "max shorts exceeded"
  //       );
  //     }
  //   }
  // }
}

