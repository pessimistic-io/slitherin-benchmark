// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.4;
pragma abicoder v2;

import "./IERC20.sol";
import "./IERC721.sol";
import "./SafeERC20.sol";
import "./SafeMath.sol";
import "./Context.sol";
import "./Initializable.sol";
import "./TickMath.sol";
import "./FullMath.sol";
import "./IHypervisor.sol";
import "./IPersonalVault.sol";
import "./IManager.sol";
import "./IStrategy.sol";
import "./IVault.sol";
import "./IPositionRouterCallbackReceiver.sol";
import "./IRouter.sol";
import "./IPositionRouter.sol";


/**
 * @notice
 *  need to restrict the vault to have only 1 open position at the same time, if not, difficult to manage positions because of async operations
 */
contract PerpetualVault is Context, IPositionRouterCallbackReceiver, IPersonalVault {
  using SafeERC20 for IERC20;
  using SafeMath for uint256;

  struct PositionInfo {
    address collateralToken;
    address indexToken;
    bool isLong;
    uint256 size;
    uint256 collateral;
    uint256 averagePrice;
    uint256 entryFundingRate;
    uint256 reserveAmount;
    uint256  realisedPnl;
    bool isPositivePnl;
    uint256 lastIncreasedTime;
  }

  struct PositionKeyInfo {              //  positionKey = keccak256(abi.encodePacked(_account=address(this), _collateralToken, _indexToken, _isLong)
    address collateralToken;
    address indexToken;
    bool isLong;
  }

  struct PositionRequestQueue {
    bytes32 requestKey;                 //  requestKey generated by PositionRouter contract of GMX
    address collateralToken;
    address indexToken;
    bool isLong;
    address caller;                     //  caller of position request
    bool isWithdrawal;                  //  there may be a liquidate action. in that case, we can't use boolean type to check action type
    address beneficiary;                //  receipient of withdraw action. necessary if `isDeposit` is false
    uint256 amount;                     //  share token amount, would be used in withdraw action. necessary if `isDeposit` is false
  }

  IManager public _manager;
  bytes32 private _referralCode;

  // Vault variables
  uint256 public constant PRECISION = 1e36;
  uint256 public constant BASIS_POINTS_DIVISOR = 10_000;
  uint256 public vaultId;
  uint256 public hedgeFactor; // 2 = 50% pricipal, 10 = 10% prinicpal required, etc
  IHypervisor public lp; // hypervisor contract
  IERC20 public hedgeToken; // token0 or token1 of hypervisor contract
  IVault public gmxVault;
  address public positionRouter;
  address public gmxRouter;
  address public keeper;
  address public _strategy;
  bool public isLong;
  address public indexToken;
  uint256 public lookback;
  bytes nextAction;

  uint256 totalAssets;                   //  total lp value in terms of token1
  bytes32 public currentPositionKey;     //  current open positionKey
  // bytes32[] public positions;         //  positionKey is generated based on `collateralToken`, `indexToken`, `account` and `isLong`.
  //                                     //   so positions array length can't be large. this is why chosed type as array rather than mapping.
  mapping(bytes32 => PositionKeyInfo) public positionKeyInfo;
  
  //  if balance is not enough when withdrawing, `withdraw` function create position.
  //   so withdrawing action can't be done in one transaction. 
  //   register withdraw amount and address to this variable to reference in the callback function
  //   of execute position action called by GMX keeper 
  PositionRequestQueue public queue;
  bool _isLock;
  uint256 _slippage;
  uint256 _leverage;

  event GmxPositionCallbackCalled(
    bytes32 requestKey,
    bool isExecuted,
    bool isIncrease
  );

  modifier onlyOwner() {
    require(_manager.ownerOf(vaultId) == msg.sender, "!owner");
    _;
  }

  modifier onlyManager() {
    require(msg.sender == address(_manager), "!manager");
    _;
  }

  modifier onlyKeeper() {
    require(msg.sender == keeper || msg.sender == address(_manager), "!keeper");
    _;
  }

  // we will lock the contract from the moment we create position to the moment we get the callback from GMX keeper for security
  modifier lock() {
    require(_isLock == false, "locked");
    _;
  }

  /**
   * @notice
   *  `hedgeToken` can be ETH, WETH, BTC, LINK, UNI, USDC, USDT, DAI, FRAX.
   *  if we want another token, need to use external DEX to swap.
   * @param _keeper keeper address
   * @param _inputs address array, is used to initialize
   * @param _config bytes array, is used to initialize
   */
  function initialize(
    uint256 _vaultId,
    address _keeper,
    address _strategyAddress,
    address[] memory _inputs,
    bytes memory _config
  ) external payable override {
    _strategy = _strategyAddress;
    lp = IHypervisor(_inputs[0]);
    require(address(lp) != address(0), "zero address");
    indexToken = _inputs[1];
    require(indexToken != address(0), "zero address");
    address _hedgeToken = _inputs[2];
    require(_hedgeToken != address(0), "zero address");
    require(lp.token0() == _hedgeToken || lp.token1() == _hedgeToken, "invalid hedge token");
    hedgeToken = IERC20(_inputs[2]);
    gmxVault = IVault(0x489ee077994B6658eAfA855C308275EAd8097C4A);
    gmxRouter = address(0xaBBc5F99639c9B6bCb58544ddf04EFA6802F4064);
    positionRouter = address(0xb87a436B93fFE9D75c5cFA7bAcFff96430b09868);
    keeper = _keeper;
    vaultId = _vaultId;
    _referralCode = abi.decode(_config, (bytes32));
    lookback = 12;
    hedgeFactor = 10;
    _slippage = 30;   // 0.3%
    _leverage = 20_000;
    
    _manager = IManager(msg.sender);

    //  approve gmx address
    IRouter(gmxRouter).approvePlugin(positionRouter);
    hedgeToken.safeApprove(gmxRouter, type(uint256).max);
    hedgeToken.safeApprove(positionRouter, type(uint256).max);
  }

  //  need payable to receive ETH when opening position
  receive() external payable {}

  /**
   * @notice
   *  deposit hypervisor token together with hedge token
   * @param amount amount of hypervisor token
   */
  function deposit(uint256 amount) external onlyOwner lock override {
    uint256 principal = amount.mul(getLpValueInToken1()).div(PRECISION); // get lp value of amount in terms of token1
    uint256 requiredHedge = principal.div(hedgeFactor); // get value of hedge token required in terms of token1
    require(requiredHedge > 0, "too small amount");

    uint256 hedgeAmount = requiredHedge; // get hedge amount
    if (lp.token0() == address(hedgeToken)) {
      hedgeAmount = getPriceToken1InToken0().mul(requiredHedge).div(PRECISION);
    }

    lp.transferFrom(msg.sender, address(this), amount);
    hedgeToken.safeTransferFrom(msg.sender, address(this), hedgeAmount);
  }

  /**
   * @notice
   *  withdraw hypervisor token together with hedge token
   *  if the amount of hedge token, corresponding to hypervisor amount to withdraw, is insufficient, 
   *   create a position request to withdraw hedge token from gmx position and real withdraw action is
   *    done by `gmxPositionCallback` function in the following block.
   * @param recipient address to receive tokens
   * @param amount amount of hypervisor token to withdraw
   * @param forced if true, withdraw without requesting position changes. just withdraw from the balance 
   *  even if it's insufficient
   */
  function withdraw(address recipient, uint256 amount, bool forced) public onlyOwner lock override {
    _withdraw(recipient, amount, forced);
  }

  function run() external lock onlyKeeper payable override {
    bool _isLong = IStrategy(_strategy).getSignal(indexToken, lookback);
    
    uint256 minOut = 0;
    address _collateralToken;
    if (_isLong == true) {
      _collateralToken = indexToken;
    } else {
      _collateralToken = address(hedgeToken);
    }
    if (isLong == _isLong) {
      _createIncreasePosition(_collateralToken, 0, minOut, 0, isLong);
    } else {
      if (currentPositionKey != hex'') {   // if already have a position
        nextAction = abi.encodeWithSignature(
          '_createIncreasePosition(address,uint256,uint256,uint256,bool)',
          _collateralToken, 0, minOut, 0, _isLong
        );
        _createDecreasePosition(_collateralToken, 0, 0, isLong, minOut);
      } else {
        _createIncreasePosition(_collateralToken, 0, minOut, 0, _isLong);
      }
    }
  }

  /**
   * @notice
   *  this function is generally not used because GMX has a keeper and the keeper detects
   *   `createIncreasePosition` action of `PositionRouter` contract and triggers position execution actions.
   *  But GMX docs says keeper may miss orders by accident,
   *   in that case, needs to trigger execution manually.
   */
  function triggerExecutePositionRequest(bytes32 requestKey, bool isOpen) external onlyManager {
    // Manual execution is possible `minTimeDelayPublic` seconds later after position created.
    uint256 minTimeDelayPublic = IPositionRouter(positionRouter).minTimeDelayPublic();
    if (isOpen) {
      IncreasePositionRequest memory request = IPositionRouter(positionRouter).increasePositionRequests(requestKey);
      require(request.blockTime.add(minTimeDelayPublic) <= block.timestamp, "delay");
      IPositionRouter(positionRouter).executeIncreasePosition(requestKey, payable(this));
    } else {
      DecreasePositionRequest memory request = IPositionRouter(positionRouter).decreasePositionRequests(requestKey);
      require(request.blockTime.add(minTimeDelayPublic) <= block.timestamp, "delay");
      IPositionRouter(positionRouter).executeDecreasePosition(requestKey, payable(this));
    }
    _isLock = false;
  }

  /**
   * @notice
   *  this function is a callback of execute position action from GMX Position Router
   *  can be used for several purpose in the future
   */
  function gmxPositionCallback(bytes32 requestKey, bool isExecuted, bool isIncrease) override external {
    require(msg.sender == address(positionRouter), "invalid caller");
    require(queue.requestKey == requestKey, "invalid request callback");

    _isLock = false;
    if (isExecuted) {
      // add positionKey to position list array
      currentPositionKey = keccak256(abi.encodePacked(
        address(this),
        queue.collateralToken,
        queue.indexToken,
        queue.isLong
      ));
      positionKeyInfo[currentPositionKey] = PositionKeyInfo(
        queue.collateralToken,
        queue.indexToken,
        queue.isLong
      );
      isLong = queue.isLong;

      if (nextAction.length != 0) {
        (bool success, ) = address(this).call(nextAction);      // need to consider later if call method is appropriate instead of function
        require(success, "failed to call the next action");
        delete nextAction;
      }
    }
    delete queue;

    emit GmxPositionCallbackCalled(requestKey, isExecuted, isIncrease);
  }

  function fundVault(uint256 _amount) external onlyOwner {
    payable(this).transfer(_amount);
  }

  function prepareBurn() external override onlyManager {
    payable(_manager.ownerOf(vaultId)).transfer(address(this).balance);
    uint256 amount = lp.balanceOf(address(this));
    if (amount == 0) return;
    _withdraw(_manager.ownerOf(vaultId), amount, false);
  }

  //////////////////////////////
  ////    View Functions    ////
  //////////////////////////////

  /**
   * @notice
   *  check the description of `_estimatedTotalHedgeAmount`
   */
  function estimatedTotalAsset() public view override returns (uint256) {
    return hedgeToken.balanceOf(address(this)) + _estimatedHedgeAmount(currentPositionKey);
  }

  // function estimatedTotalHedgeAmount(bytes32 positionKey) external view returns (uint256) {
  //   return _estimatedHedgeAmount(positionKey);
  // }

  function getPriceToken1InToken0() public view returns (uint256) {
    uint256 priceToken0InToken1 = getPriceToken0InToken1();
    require(priceToken0InToken1 != 0, "pool unstable");
    return PRECISION.mul(PRECISION).div(priceToken0InToken1);
  }

  function getPriceToken0InToken1() public view returns (uint256) {
    uint160 sqrtPrice = TickMath.getSqrtRatioAtTick(lp.currentTick());
    uint256 price = FullMath.mulDiv(uint256(sqrtPrice).mul(uint256(sqrtPrice)), PRECISION, 2**(96 * 2));
    return price;
  }

  function getLpValueInToken1() public view returns(uint256) {
    (uint256 token0, uint256 token1) = lp.getTotalAmounts();
    uint256 totalValue = token0.mul(getPriceToken0InToken1()).add(token1.mul(PRECISION));
    return totalValue.div(lp.totalSupply());
  }

  function getPositionInfo(bytes32 positionKey) external view returns (PositionInfo memory) {
    (
      uint256 size,
      uint256 collateral,
      uint256 averagePrice,
      uint256 entryFundingRate,
      uint256 reserveAmount,
      int256 realisedPnl,
      uint256 lastIncreasedTime
    ) = gmxVault.positions(positionKey);
    
    PositionKeyInfo memory pkInfo = positionKeyInfo[positionKey];
    
    return PositionInfo({
      collateralToken: pkInfo.collateralToken,
      indexToken: pkInfo.indexToken,
      isLong: pkInfo.isLong,
      size: size,
      collateral: collateral,
      averagePrice: averagePrice,
      entryFundingRate: entryFundingRate,
      reserveAmount: reserveAmount,
      realisedPnl: realisedPnl > 0 ? uint256(realisedPnl) : uint256(-realisedPnl),
      isPositivePnl: realisedPnl >= 0,
      lastIncreasedTime: lastIncreasedTime
  });
  }

  function manager() external view returns (address) {
    return address(_manager);
  }

  function referralCode() external view returns (bytes32) {
    return _referralCode;
  }

  function isLock() external view returns (bool) {
    return _isLock;
  }

  function slippage() external view returns (uint256) {
    return _slippage;
  }

  function strategy() external view override returns (address) {
    return _strategy;
  }

  function setHedgeFactor(uint256 _hedgeFactor) external onlyManager {
    require(_hedgeFactor != 0, "zero value");
    hedgeFactor = _hedgeFactor;
  }

  function setReferralCode(bytes32 _code) external onlyManager {
    _referralCode = _code;
  }

  function setLock(bool locked) external onlyManager {
    _isLock = locked;
  }

  function setSlippage(uint256 val) external onlyOwner {
    _slippage = val;
  }

  function setTradingToken(address _indexToken) external onlyOwner {
    require(_indexToken == address(0), "zero address");
    indexToken = _indexToken;
  }

  function setLeverageValue(uint256 val) external onlyOwner {
    require(val > BASIS_POINTS_DIVISOR, "low than minimum");
    require(val < gmxVault.maxLeverage(), "exceed maximum value");
    _leverage = val;
  }

  function setLookbackPeriod(uint256 _lookback) external onlyOwner {
    lookback = _lookback;
  }
  
  //////////////////////////////
  ////  Internal Functions  ////
  //////////////////////////////

  /**
   * @notice
   *  create increase position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't open position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralToken the address of token to be used as collateral. 
   *  in long position, `collateralToken` should the same as `indexToken`.
   *  in short position, `collateralToken` should be stable coin.
   * @param amountIn: the amount of tokenIn you want to deposit as collateral
   * @param minOut: the min amount of collateralToken to swap for
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createIncreasePosition(
    address collateralToken,
    uint256 amountIn,
    uint256 minOut,
    uint256 sizeDelta,
    bool _isLong
  ) private lock {
    if (_isLong == true) {
      require(indexToken == collateralToken, "invalid collateralToken");
    }
    require(address(this).balance >= IPositionRouter(positionRouter).minExecutionFee(), "too low execution fee");
    // require(
    //   sizeDelta > gmxVault.tokenToUsdMin(address(hedgeToken), amountIn),
    //   "too low leverage"
    // );
    // require(
    //   sizeDelta.div(gmxVault.tokenToUsdMin(address(hedgeToken), amountIn)) < gmxVault.maxLeverage().div(BASIS_POINTS_DIVISOR),
    //   "exceed max leverage"
    // );
    // check available amounts to open positions
    if (amountIn == 0) {
      amountIn = hedgeToken.balanceOf(address(this));
    }
    if (sizeDelta == 0) {
      sizeDelta = gmxVault.tokenToUsdMin(address(hedgeToken), amountIn) * _leverage / BASIS_POINTS_DIVISOR;
    }
    
    _checkPool(_isLong, indexToken, collateralToken, sizeDelta);

    if (currentPositionKey == hex'') {
      /* code to check minimum open position amount in the case of first opening */
    }
    
    address[] memory path = _getPath(collateralToken, true);
    
    uint256 priceBasisPoints = _isLong ? BASIS_POINTS_DIVISOR + _slippage : BASIS_POINTS_DIVISOR - _slippage;
    uint256 refPrice = _isLong ? gmxVault.getMaxPrice(indexToken) : gmxVault.getMinPrice(indexToken);
    uint256 acceptablePrice = refPrice.mul(priceBasisPoints).div(BASIS_POINTS_DIVISOR);
    
    bytes32 requestKey = IPositionRouter(positionRouter).createIncreasePosition{value: IPositionRouter(positionRouter).minExecutionFee()}(
      path,
      indexToken,
      amountIn,
      minOut,       // it's better to provide minimum output token amount from a caller rather than calculate here
      sizeDelta,    // we can set sizeDelta based on leverage value. need to decide which one is preferred
      _isLong,
      acceptablePrice,   // current ETH mark price, check which is more efficient between minPrice and maxPrice
      IPositionRouter(positionRouter).minExecutionFee(),
      _referralCode,
      address(this)
    );

    //  update state variables
    _isLock = true;
    queue.caller = msg.sender;
    queue.requestKey = requestKey;
    queue.collateralToken = collateralToken;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  /**
   * @notice
   *  create decrease position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't close position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralToken the address of token to be used as collateral. 
   *  in long position, `collateralToken` should the same as `indexToken`.
   *  in short position, `collateralToken` should be stable coin.
   * @param collateralDelta: the amount of collateral in USD value to withdraw
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   * @param minOut: the min output token amount you would receive
   */
  function _createDecreasePosition(
    address collateralToken,
    uint256 collateralDelta,
    uint256 sizeDelta,
    bool _isLong,
    uint256 minOut
  ) private lock {
    if (_isLong == true) {
      require(indexToken == collateralToken, "invalid collateralToken");
    }
    require(address(this).balance >= IPositionRouter(positionRouter).minExecutionFee(), "too low execution fee");

    if (sizeDelta == 0) {
      (uint256 size, , , , , , ) = gmxVault.positions(currentPositionKey);
      sizeDelta = size;
    }

    address[] memory path = _getPath(collateralToken, false);
    
    uint256 priceBasisPoints = _isLong ? BASIS_POINTS_DIVISOR - _slippage : BASIS_POINTS_DIVISOR + _slippage;
    uint256 refPrice = _isLong ? gmxVault.getMinPrice(indexToken) : gmxVault.getMaxPrice(indexToken);
    uint256 acceptablePrice = refPrice.mul(priceBasisPoints).div(BASIS_POINTS_DIVISOR);
    bytes32 requestKey = IPositionRouter(positionRouter).createDecreasePosition{value: IPositionRouter(positionRouter).minExecutionFee()}(
      path,
      indexToken,
      collateralDelta,
      sizeDelta,
      _isLong,
      address(this),
      acceptablePrice,
      minOut,
      IPositionRouter(positionRouter).minExecutionFee(),
      false,
      address(this)
    );

    //  update state variables
    _isLock = true;
    queue.caller = msg.sender;
    queue.requestKey = requestKey;
    queue.collateralToken = collateralToken;
    queue.indexToken = indexToken;
    queue.isLong = _isLong;

  }

  function _withdraw(address recipient, uint256 amount, bool forced) internal {
    require(recipient != address(0), "zero address");
    require(amount <= lp.balanceOf(address(this)), "exceed balance");
    if (amount == 0) {
      amount = lp.balanceOf(address(this));
    }
    require(amount != 0, "zero value");
    // get amount to withdraw from the estimated total hedgeAmount(balance + GMX liquidity)
    uint256 hedgeAmountToWithdraw = estimatedTotalAsset() * amount / lp.balanceOf(address(this));
    uint256 hedgeTokenBalance = hedgeToken.balanceOf(address(this));
    if (hedgeTokenBalance >= hedgeAmountToWithdraw) {
      hedgeToken.safeTransfer(recipient, hedgeAmountToWithdraw);
      hedgeTokenBalance = hedgeTokenBalance.sub(hedgeAmountToWithdraw);
      lp.transfer(recipient, amount);
      return;
    }

    if (forced) {
      hedgeToken.safeTransfer(recipient, hedgeToken.balanceOf(address(this)));
      hedgeTokenBalance = 0;
      lp.transfer(recipient, amount);
      return;
    }
    
    // if we don't have enough balance, need to withdraw from GMX
    //  when decreasing position, we can't indicate amount of hedge token to withdraw using collateralDelta
    //   because `swapFee` and `closeFee` would be deducted from `amountOut`. it may need to multiply 1.01. should check exact multiplier value via testing
    uint256 amountToDecrease = hedgeAmountToWithdraw.sub(hedgeTokenBalance).mul(10100).div(BASIS_POINTS_DIVISOR);
          
    (uint256 size, , , , , , ) = gmxVault.positions(currentPositionKey);
    
    PositionKeyInfo memory pkInfo = positionKeyInfo[currentPositionKey];

    uint256 estimatedHedgeAmount = _estimatedHedgeAmount(currentPositionKey);
    uint256 sizeDelta;
    uint256 collateralDelta;
    if (amountToDecrease > estimatedHedgeAmount) {
      sizeDelta = size;
      collateralDelta = gmxVault.tokenToUsdMin(address(hedgeToken), estimatedHedgeAmount);      // can be set as 0
    } else {
      //  may need to consider fee deduction
      sizeDelta = amountToDecrease.mul(size).div(estimatedHedgeAmount);   //  amountToDecrease * size / netValue
      collateralDelta = gmxVault.tokenToUsdMin(address(hedgeToken), amountToDecrease);          // can be set as 0
    }

    nextAction = abi.encodeWithSignature("withdraw", recipient, amount, true);
    _createDecreasePosition(pkInfo.collateralToken, collateralDelta, sizeDelta, pkInfo.isLong, 0);
  }

  /**
   * @notice
   *  check available liquidity before create positions
   */
  function _checkPool(bool _isLong, address _indexToken, address collateralToken, uint256 sizeDelta) internal view {
    uint256 availableTokens = gmxVault.poolAmounts(collateralToken).sub(gmxVault.reservedAmounts(collateralToken));
    require(sizeDelta < gmxVault.tokenToUsdMin(collateralToken, availableTokens), "max longs / shorts exceeded");
    
    if (_isLong) {
      uint256 maxGlobalLongSize = IPositionRouter(positionRouter).maxGlobalLongSizes(_indexToken);
      if (maxGlobalLongSize != 0) {
        require(
          gmxVault.guaranteedUsd(_indexToken).add(sizeDelta) < maxGlobalLongSize,
          "max longs exceeded"
        );
      }
    } else {
      uint256 maxGlobalShortSize = IPositionRouter(positionRouter).maxGlobalShortSizes(_indexToken);
      if (maxGlobalShortSize != 0) {
        require(
          gmxVault.globalShortSizes(_indexToken).add(sizeDelta) < maxGlobalShortSize,
          "max shorts exceeded"
        );
      }
    } 
  }

  // /**
  //  * @notice
  //  *  calculate the total potential hedge token amount.
  //  *  `current balance` + `GMX balance`
  //  */
  // function _estimatedTotalHedgeAmount() internal view returns (uint256) {
  //   uint256 hedgeAmount = hedgeTokenBalance;
  //   for (uint8 i = 0; i < positions.length; i++) {
  //     hedgeAmount = hedgeAmount.add(_estimatedHedgeAmount(positions[i]));
  //   }
  //   return hedgeAmount;
  // }

  /**
   * @notice
   *  `openFee` is deducted when opening position. openFee = sizeDelta * 0.1%
   *  `closeFee` is deducted when closing position. closeFee = sizeDelta * 0.1%
   *  `borrowFee` is deducted when position size change. borrowFee = size * fundingRate. reset to 0 whenever position change.
   *  `swapFee` is deducted when swapping `collateralToken` to `tokenOut`==`hedgeToken`.
   *    we will ignore `swapFee` when estimating hedge token amount
   */
  function _estimatedHedgeAmount(bytes32 positionKey) internal view returns (uint256) {
    (uint256 size, uint256 collateral, , uint256 entryFundingRate, , , ) = gmxVault.positions(positionKey);
    if (size == 0) return 0;
    (bool hasProfit, uint256 delta) = gmxVault.getPositionDelta(
      address(this),
      positionKeyInfo[positionKey].collateralToken,
      positionKeyInfo[positionKey].indexToken,
      positionKeyInfo[positionKey].isLong
    );

    uint256 cumulativeFundingRate = gmxVault.cumulativeFundingRates(positionKeyInfo[positionKey].collateralToken);
    uint256 borrowFee = size.mul(cumulativeFundingRate.sub(entryFundingRate).div(1e6));       // gmxVault.getFundingFee()
    uint256 closeFee = size.mul(gmxVault.marginFeeBasisPoints()).div(BASIS_POINTS_DIVISOR);   // gmxVault.getPositionFee()
    // uint256 swapFee = positionKeyInfo[positionKey].collateralToken == address(hedgeToken) ? 0 : ;
    uint256 netValue;
    if (hasProfit) {
      netValue = collateral.add(delta).sub(borrowFee).sub(closeFee);
    } else {
      netValue = collateral.sub(delta).sub(borrowFee).sub(closeFee);
    }
    
    uint256 hedgeAmount = gmxVault.usdToTokenMin(address(hedgeToken), netValue);

    return hedgeAmount;
  }

  function _getPath(address _collateralToken, bool isIncrease) private view returns (address[] memory) {
    address[] memory path;
    if (address(hedgeToken) == _collateralToken) {
      path = new address[](1);
      path[0] = address(hedgeToken);
    } else {
      path = new address[](2);
      if (isIncrease) {
        path[0] = address(hedgeToken);
        path[1] = _collateralToken;
      } else {
        path[0] = _collateralToken;
        path[1] = address(hedgeToken);
      }
    }
    return path;
  }

}

