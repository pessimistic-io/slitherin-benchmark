// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.4;
pragma abicoder v2;

import "./IERC20.sol";
import "./SafeERC20.sol";
import "./Ownable2StepUpgradeable.sol";
import "./IPersonalVault.sol";
import "./IManager.sol";
import "./IDataStore.sol";
import "./IReader.sol";
import "./IExchangeRouter.sol";
import "./IGmxUtils.sol";

import "./console.sol";

/**
 * @notice
 *  need to restrict the vault to have only 1 open position at the same time, if not, difficult to manage positions because of async operations
 */
contract PerpetualVault is Initializable, Ownable2StepUpgradeable {
  using SafeERC20 for IERC20;

  struct PositionRequestQueue {
    bytes32 requestKey;                 //  requestKey generated by PositionRouter contract of GMX
    bool isLong;
  }

  enum NextActionSelector {
    NO_ACTION,
    DEPOSIT_ACTION,
    INCREASE_ACTION,
    DECREASE_WITHDRAW_ACTION,
    CREATE_DECREASE_ORDER,
    WITHDRAW_ACTION,
    INCREASE_ACTION_ON_IDLE
  }

  struct Action {
    NextActionSelector selector;
    bytes data;
  }

  string public name;
  IManager public manager;
  bytes32 private _referralCode;

  // Vault variables
  uint256 public constant PRECISION = 1e30;
  uint256 public constant BASIS_POINTS_DIVISOR = 10_000;

  uint256 public totalShares;
  mapping (address => uint256) public shares;
  mapping (address => uint256) public initialDeposit;

  address public market;
  address public indexToken;
  IERC20 public collateralToken;
  IReader public gReader;
  IGmxUtils public gmxUtils;
  address public gDataStore;
  
  address public keeper;
  address public _strategy;
  bytes32 public curPositionKey;      //  current open positionKey
  uint256 public minFund;             // 30 decimals
  uint256 public minCollateralUsd;             // 30 decimals
  uint256 public minEth;
  uint256 public governanceFee;
  uint256 public callbackGasLimit;
  //  if balance is not enough when withdrawing, `withdraw` function create position.
  //   so withdrawing action can't be done in one transaction. 
  //   register withdraw amount and address to this variable to reference in the callback function
  //   of execute position action called by GMX keeper 
  PositionRequestQueue public queue;
  
  bool public beenLong;               // status value
  bool public closed;                 // status value
  Action public nextAction;           // status value
  
  // bytes sltp;                         // status value
  bool _isLock;                       // status value
  
  uint256 _slippage;
  uint256 _leverage;
  uint256 _gasBufferFactor;
  bytes[] swapData;
  MarketPrices marketPrices;

  bool _entered;                      // status value

  event GmxPositionCallbackCalled(
    bytes32 requestKey,
    bool isIncrease
  );

  modifier onlyVault() {
    uint256 vaultId = IPersonalVault(msg.sender).vaultId();
    require(manager.vaultMap(vaultId) == msg.sender, "invalid caller");
    _;
  }

  modifier onlyKeeper() {
    require(msg.sender == keeper || msg.sender == address(manager), "!keeper");
    _;
  }

  // we will lock the contract from the moment we create position to the moment we get the callback from GMX keeper
  modifier gmxLock() {
    require(_isLock == false, "gmx action lock");
    _;
  }

  // we prevent calling functions while previous action is still being processed.
  modifier nonReentrant() {
    require(_entered == false, "reentrant call");
    _entered = true;
    _;
  }

  /**
   * @notice
   *  `collateralToken` can be ETH, WETH, BTC, LINK, UNI, USDC, USDT, DAI, FRAX.
   *  if we want another token, need to use external DEX to swap.
   * @param _keeper keeper address
   */
  function initialize(
    string memory _name,
    address _market,
    address _collateralToken,
    address _manager,
    address _keeper,
    address _gmxUtils,
    bytes32 _refCode
  ) external initializer {
    __Ownable2Step_init();
    name = _name;
    require(_market != address(0), "zero address");
    require(_collateralToken != address(0), "zero address");
    require(_gmxUtils != address(0), "zero address");
    market = _market;
    collateralToken = IERC20(_collateralToken);
    gReader = IReader(0xf60becbba223EEA9495Da3f606753867eC10d139);
    gDataStore = address(0xFD70de6b91282D8017aA4E741e9Ae325CAb992d8);
    gmxUtils = IGmxUtils(_gmxUtils);
    gmxUtils.setEnvVars(address(this), _manager);
    MarketProps memory marketInfo = gReader.getMarket(gDataStore, market);
    indexToken = marketInfo.indexToken;
    keeper = _keeper;
    _referralCode = _refCode;
    governanceFee = 500;  // 5%
    _slippage = 30;   // 0.3%
    _leverage = 20_000;
    _gasBufferFactor = 12_000;
    minCollateralUsd = 10 * PRECISION;
    minEth = 0.002 ether;
    callbackGasLimit = 2_000_000;
    closed = true;
    
    require(_manager != address(0), "zero address");
    manager = IManager(_manager);

    // approve `collateralToken` and `indexToken` on `SwapRouter02` contract of uniswap v3
    collateralToken.safeApprove(address(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45), type(uint256).max);
    IERC20(indexToken).safeApprove(address(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45), type(uint256).max);
  }

  //  need payable to receive ETH when opening position
  receive() external payable {}

  /**
   * @notice
   *  deposit hypervisor token together with hedge token
   * @param amount amount of hypervisor token
   */
  function deposit(uint256 amount) external onlyVault nonReentrant {
    require(amount > 0, "zero amount");
    collateralToken.safeTransferFrom(msg.sender, address(this), amount);
    // mint share token in the NextAction to involve off-chain price data and improve security
    nextAction.selector = NextActionSelector.DEPOSIT_ACTION;
    nextAction.data = abi.encode(msg.sender, amount);
  }

  /**
   * @notice
   *  withdraw hypervisor token together with hedge token
   *  if the amount of hedge token, corresponding to hypervisor amount to withdraw, is insufficient, 
   *   create a position request to withdraw hedge token from gmx position and real withdraw action is
   *    done by `gmxPositionCallback` function in the following block.
   * @param _shares share amount of hedge token to withdraw
   */
  function withdraw(address recipient, uint256 _shares) public onlyVault nonReentrant {
    require(address(gmxUtils).balance > minEth, "low than minium eth balance");
    require(recipient != address(0), "zero address");
    require(_shares != 0, "zero amount");
    require(_shares <= shares[msg.sender], "exceed due");
    nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
    nextAction.data = abi.encode(msg.sender, recipient, _shares, false, 0);
  }

  /**
   * 
   * @param isOpen if true, open a position, if false, close a current position
   * @param isLong if true, open a long position, if false, open a short position
   * @param sl stop loss value. its decimals is 30
   * @param tp take profit value. its decimals is 30
   */
  function run(bool isOpen, bool isLong, uint256 sl, uint256 tp, MarketPrices memory prices, bytes[] memory _swapData) external nonReentrant onlyKeeper {
    require(address(gmxUtils).balance > minEth, "low than minium eth balance");
    marketPrices = prices;
    swapData = _swapData;

    if (isOpen) {
      if (closed == true) {
        require(_isFundIdle() == true, "no enough balance to open position");
        _createIncreasePosition(0, 0, isLong, sl, tp);
      } else {
        if (beenLong == isLong) {
          _createDecreaseOrder(sl, tp, false);
        } else {
          nextAction.selector = NextActionSelector.INCREASE_ACTION;
          bytes memory sltp = abi.encode(sl, tp);
          nextAction.data = abi.encode(uint256(0), uint256(0), isLong, sltp);
          _createDecreasePosition(0, 0, beenLong);
        }
      }
    } else {
      if (closed == false) {
        nextAction.selector = NextActionSelector.CREATE_DECREASE_ORDER;
        nextAction.data = abi.encode(0, 0);
        _createDecreasePosition(0, 0, beenLong);
      } else {
        revert("no action needed");
      }
    }
  }

  function runNextAction(MarketPrices memory prices, bytes[] memory _swapData) external gmxLock onlyKeeper {
    marketPrices = prices;
    swapData = _swapData;
    if (nextAction.selector == NextActionSelector.DEPOSIT_ACTION) {
      (address caller, uint256 amount) = abi.decode(nextAction.data, (address, uint256));
      _issueShares(caller, amount, true);
      if (closed == false) {
        (uint256 sl, uint256 tp) = _cancelPendingOrders();
        _createIncreasePosition(0, 0, beenLong, sl, tp);
      } else {
        _entered = false;
        delete nextAction;
      }
    } else if (nextAction.selector == NextActionSelector.INCREASE_ACTION) {
      (
        uint256 amountIn,
        uint256 sizeDelta,
        bool _isLong,
        bytes memory sltp
      ) = abi.decode(nextAction.data, (uint256, uint256, bool, bytes));
      delete nextAction;
      (uint256 sl, uint256 tp) = abi.decode(sltp, (uint256, uint256));
      _createIncreasePosition(amountIn, sizeDelta, _isLong, sl, tp);
    } else if (nextAction.selector == NextActionSelector.DECREASE_WITHDRAW_ACTION) {
      (
        uint256 collateralDelta,
        uint256 sizeDelta,
        bool _isLong,
        bytes memory withdrawData
      ) = abi.decode(nextAction.data, (uint256, uint256, bool, bytes));
      nextAction.selector = NextActionSelector.WITHDRAW_ACTION;
      nextAction.data = withdrawData;
      _createDecreasePosition(collateralDelta, sizeDelta, _isLong);
    } else if (nextAction.selector == NextActionSelector.CREATE_DECREASE_ORDER) {
      (uint256 sl, uint256 tp) = abi.decode(nextAction.data, (uint256, uint256));
      _createDecreaseOrder(sl, tp, false);
      delete nextAction;
    } else if (nextAction.selector == NextActionSelector.WITHDRAW_ACTION) {
      (
        address to,
        address recipient,
        uint256 _shares,
        bool forced,
        uint256 amount
      ) = abi.decode(nextAction.data, (address, address, uint256, bool, uint256));
      _withdraw(to, recipient, _shares, forced, amount);
      _createDecreaseOrder(0, 0, true);
      delete nextAction;
    } else if (closed == false && _isFundIdle()) {
      (uint256 sl, uint256 tp) = _cancelPendingOrders();
      _createIncreasePosition(0, 0, beenLong, sl, tp);
    } else {
      revert("no next action");
    }
  }

  // /**
  //  * @notice
  //  *  this function is generally not used because GMX has a keeper and the keeper detects
  //  *   `createIncreasePosition` action of `PositionRouter` contract and triggers position execution actions.
  //  *  But GMX docs says keeper may miss orders by accident,
  //  *   in that case, needs to trigger execution manually.
  //  */

  function afterOrderExecution(bytes32 key, IGmxUtils.OrderType orderType, bool isLong, bytes32 positionKey) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    require(queue.requestKey == key, "invalid request callback");
    
    _isLock = false;
    if (orderType == IGmxUtils.OrderType.MarketIncrease) {
      curPositionKey = positionKey;
      beenLong = isLong;
      closed = false;
    } else if(orderType == IGmxUtils.OrderType.MarketDecrease) {
      uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);
      if (sizeInUsd == 0) {
        closed = true;      // need to check if `closed` should be false even though no position.
        curPositionKey = bytes32(0);
      }
    } else if (orderType == IGmxUtils.OrderType.MarketSwap) {
      beenLong = queue.isLong;
      if (beenLong) {
        closed = false;
      } else {
        closed = true;
      }
    } else if (orderType == IGmxUtils.OrderType.LimitDecrease || orderType == IGmxUtils.OrderType.StopLossDecrease) {
      curPositionKey = bytes32(0);
      closed = true;
      _cancelPendingOrders();
    }
    delete queue;
    if (nextAction.selector == NextActionSelector.NO_ACTION) {
      _entered = false;
    }
    emit GmxPositionCallbackCalled(key, true);
  }

  function afterOrderCancellation(bytes32 key, IGmxUtils.OrderType, bool, bytes32) external {
    require(msg.sender == address(gmxUtils), "invalid caller");
    _isLock = false;
    delete nextAction;
    emit GmxPositionCallbackCalled(key, false);
  }

  function afterOrderFrozen(bytes32 key, IGmxUtils.OrderType, bool, bytes32) external {}

  //////////////////////////////
  ////    View Functions    ////
  //////////////////////////////

  /**
   * @notice
   *  this is just for frontend information. not used in contract logic because value is not accurate.
   */
  function totalAmount(MarketPrices memory prices) external view returns (uint256) {
    if (curPositionKey == bytes32(0)) {
      if (closed == true) {
        return collateralToken.balanceOf(address(this));
      } else {
        uint256 balance = IERC20(indexToken).balanceOf(address(this));
        uint256 amountInCollateralToken = balance * manager.getTokenPrice(indexToken) / manager.getTokenPrice(address(collateralToken));
        return collateralToken.balanceOf(address(this)) + amountInCollateralToken;
      }
    }
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, prices);
    return collateralToken.balanceOf(address(this)) + positionData.netValue / prices.shortTokenPrice.max;
  }

  function _totalValue() internal view returns (uint256) {
    if (closed == true) {
      return collateralToken.balanceOf(address(this)) * marketPrices.shortTokenPrice.min;
    } else if (curPositionKey == bytes32(0)) {
      uint256 totalValue = IERC20(indexToken).balanceOf(address(this)) * marketPrices.longTokenPrice.min
        + collateralToken.balanceOf(address(this)) + marketPrices.shortTokenPrice.min;
      return totalValue;
    } else {
      IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
      uint256 totalValue = positionData.netValue + collateralToken.balanceOf(address(this)) * marketPrices.shortTokenPrice.min;
      return totalValue;
    }
  }

  function getPositionInfo() external view returns (address, address, uint256, uint256,uint256, uint256, bool) {
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
    return (
      market,
      address(collateralToken),
      positionData.sizeInUsd,
      positionData.sizeInTokens,
      positionData.collateralAmount,
      positionData.netValue,
      positionData.isLong
    );
  }

  function isNextAction() external view returns (NextActionSelector) {
    if (_isLock == true ) {
      return NextActionSelector.NO_ACTION;
    } else if (nextAction.selector != NextActionSelector.NO_ACTION) {
      return nextAction.selector;
    } else if (closed == false && _isFundIdle()) {
      return NextActionSelector.INCREASE_ACTION_ON_IDLE;
    } else {
      return NextActionSelector.NO_ACTION;
    }
  }

  function isBusy() external view returns (bool) {
    return _entered;
  }

  function referralCode() external view returns (bytes32) {
    return _referralCode;
  }

  function isLock() external view returns (bool) {
    return _isLock;
  }

  function slippage() external view returns (uint256) {
    return _slippage;
  }

  function strategy() external view returns (address) {
    return _strategy;
  }

  function setKeeper(address _keeper) external onlyOwner {
    require(_keeper != address(0), "zero address");
    keeper = _keeper;
  }

  function setGmxUtils(address _gmxUtils) external onlyOwner {
    require(_gmxUtils != address(0), "zero address");
    uint256 amount;
    if (address(gmxUtils) != address(0)) {
      amount = gmxUtils.withdrawEth();
    }
    gmxUtils = IGmxUtils(_gmxUtils);
    gmxUtils.setEnvVars(address(this), address(manager));
    if (amount > 0) {
      payable(_gmxUtils).transfer(amount);
    }    
  }

  function setLock(bool locked) external onlyOwner {
    _isLock = locked;
  }

  // this is just for development
  function setEntered() external onlyOwner {
    _entered = false;
  }

  function setSlippage(uint256 val) external onlyOwner {
    _slippage = val;
  }

  function setLeverageValue(uint256 val) external onlyOwner {
    require(val > BASIS_POINTS_DIVISOR, "low than minimum");
    _leverage = val;
  }

  function setMinFund(uint256 _minFund) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minFund >= min, "minimum");
    minFund = _minFund;
  }

  function setMinCollateralUsd(uint256 _minCollateralUsd) external onlyOwner {
    uint256 min = IDataStore(gDataStore).getUint(keccak256(abi.encode("MIN_COLLATERAL_USD")));
    require(_minCollateralUsd > min, "minimum");
    minCollateralUsd = _minCollateralUsd;
  }

  function setMinEth(uint256 _minEth) external onlyOwner {
    require(_minEth > 0, "minimum");
    minEth = _minEth;
  }

  function setCallbackGasLimit(uint256 _callbackGasLimit) external onlyOwner {
    require(_callbackGasLimit > 0, "zero value");
    callbackGasLimit = _callbackGasLimit;
  }
  
  //////////////////////////////
  ////  Internal Functions  ////
  //////////////////////////////

  function _issueShares(address to, uint256 amount, bool isMint) internal {
    if (isMint) {
      uint256 _shares;
      if (totalShares > 0) {
        _shares = amount * marketPrices.shortTokenPrice.min * totalShares / _totalValue();
      } else {
        _shares = amount;
      }

      shares[to] = shares[to] + _shares;
      totalShares = totalShares + _shares;
    } else {
      shares[to] = shares[to] - amount;
      totalShares = totalShares - amount;
    }
  }

  function _isFundIdle() internal view returns (bool) {
    uint256 balance = collateralToken.balanceOf(address(this));
    if (gmxUtils.tokenToUsdMin(address(collateralToken), balance) > minFund) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @notice
   *  create increase position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't open position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param amountIn: the amount of tokenIn you want to deposit as collateral
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createIncreasePosition(
    uint256 amountIn,
    uint256 sizeDelta,
    bool _isLong,
    uint256 sl,
    uint256 tp
  ) private gmxLock {
    bytes32 requestKey;
    // check available amounts to open positions
    if (amountIn == 0) {
      amountIn = collateralToken.balanceOf(address(this));
    }
    IGmxUtils.OrderType orderType;
    if (_isLong) {
      for (uint8 i = 0; i < swapData.length; i++) {
        (PROTOCOL _protocol, bytes memory data) = abi.decode(swapData[i], (PROTOCOL, bytes));
        if (_protocol == PROTOCOL.UNISWAP) {
          (address to, bytes memory callData) = abi.decode(
            data,
            (address, bytes)
          );
          (bool success, ) = to.call(callData);
          require(success, "uniswap call reverted");
          beenLong = true;
          closed = false;
          if (nextAction.selector == NextActionSelector.NO_ACTION) {
            _entered = false;
          }
        } else {
          (address[] memory gPath) = abi.decode(data, (address[]));
          orderType = IGmxUtils.OrderType.MarketSwap;
          amountIn = collateralToken.balanceOf(address(this));
          collateralToken.safeTransfer(address(gmxUtils), amountIn);
          IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
            market: address(0),
            indexToken: address(0),
            initialCollateralToken: address(collateralToken),
            swapPath: gPath,
            isLong: _isLong,
            sizeDeltaUsd: 0,
            initialCollateralDeltaAmount: 0,
            amountIn: amountIn,
            callbackGasLimit: callbackGasLimit
          });
          _isLock = true;
          requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
        }
      }
    } else {
      nextAction.selector = NextActionSelector.CREATE_DECREASE_ORDER;
      nextAction.data = abi.encode(sl, tp);

      address[] memory swapPath;
      orderType = IGmxUtils.OrderType.MarketIncrease;
      collateralToken.safeTransfer(address(gmxUtils), amountIn);
      if (sizeDelta == 0) {
        sizeDelta = marketPrices.shortTokenPrice.max * amountIn * _leverage / BASIS_POINTS_DIVISOR;
      }
      IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
        market: market,
        indexToken: indexToken,
        initialCollateralToken: address(collateralToken),
        swapPath: swapPath,
        isLong: _isLong,
        sizeDeltaUsd: sizeDelta,
        initialCollateralDeltaAmount: 0,
        amountIn: amountIn,
        callbackGasLimit: callbackGasLimit 
      });
      _isLock = true;
      requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
    }

    //  update state variables
    queue.requestKey = requestKey;
    queue.isLong = _isLong;
  }

  /**
   * @notice
   *  create decrease position
   *  we can't interact directly with GMX vault contract because leverage was disabled by default and 
   *   can be set only by TimeLock(governance) and registered contracts. So we need to use their 
   *   peripheral contracts to do perp.
   *  this function doesn't close position actually, just register position information. Actual position
   *   opening/closing is done by a keeper of GMX vault.
   * @param collateralDelta: the amount of collateral in USD value to withdraw
   * @param sizeDelta: the USD value of the change in position size. decimals is 30
   * @param _isLong: if long, true or false
   */
  function _createDecreasePosition(
    uint256 collateralDelta,
    uint256 sizeDelta,
    bool _isLong
  ) private gmxLock {
    bytes32 requestKey;
    address[] memory swapPath;
    IGmxUtils.OrderType orderType;
    if (beenLong) {
      for (uint8 i = 0; i < swapData.length; i++) {
        (PROTOCOL _protocol, bytes memory data) = abi.decode(swapData[i], (PROTOCOL, bytes));
        if (_protocol == PROTOCOL.UNISWAP) {
          (address to, bytes memory callData) = abi.decode(
            data,
            (address, bytes)
          );
          (bool success, ) = to.call(callData);
          require(success, "uniswap call reverted");
          closed = true;
          if (nextAction.selector == NextActionSelector.NO_ACTION) {
            _entered = false;
          }
        } else {
          (address[] memory gPath, uint256 amountIn) = abi.decode(data, (address[], uint256));
          orderType = IGmxUtils.OrderType.MarketSwap;
          IERC20(indexToken).safeTransfer(address(gmxUtils), amountIn);
          IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
            market: address(0),
            indexToken: address(0),
            initialCollateralToken: indexToken,
            swapPath: gPath,
            isLong: _isLong,
            sizeDeltaUsd: 0,
            initialCollateralDeltaAmount: 0,
            amountIn: amountIn,
            callbackGasLimit: callbackGasLimit 
          });
          _isLock = true;
          requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
        }
      }
    } else {
      orderType = IGmxUtils.OrderType.MarketDecrease;
      uint256 sizeInUsd = gmxUtils.getPositionSizeInUsd(curPositionKey);
      if (
        sizeDelta == 0 ||
        sizeInUsd - sizeDelta < minCollateralUsd     // suppose we don't do above 1.1x leverage. so size is nearly the same as collateral amount
      ) {
        sizeDelta = sizeInUsd;
      }
      IGmxUtils.OrderData memory orderData = IGmxUtils.OrderData({
        market: market,
        indexToken: indexToken,
        initialCollateralToken: address(collateralToken),
        swapPath: swapPath,
        isLong: _isLong,
        sizeDeltaUsd: sizeDelta,
        initialCollateralDeltaAmount: collateralDelta,
        amountIn: 0,
        callbackGasLimit: callbackGasLimit
      });
      _isLock = true;
      requestKey = gmxUtils.createOrder(orderType, orderData, marketPrices);
    }

    //  update state variables
    queue.requestKey = requestKey;

  }

  function _createDecreaseOrder(uint256 sl, uint256 tp, bool useOld) internal {
    (uint256 _sl, uint256 _tp) = _cancelPendingOrders();
    if (useOld) {
      sl = _sl;
      tp = _tp;
    }
    if (curPositionKey != bytes32(0) && sl + tp > 0) {
      gmxUtils.createDecreaseOrder(curPositionKey, market, beenLong, sl, tp, callbackGasLimit, marketPrices);
    }
    _entered = false;
  }

  // cancel all orders when switching positions
  function _cancelPendingOrders() internal returns (uint256 sl, uint256 tp) {
    Order.Props[] memory orders = gReader.getAccountOrders(gDataStore, address(gmxUtils), 0, 1);
    if (orders.length == 0) return (sl, tp);
    for (uint8 i = 0; i < orders.length; ) {
      if (orders[i].numbers.triggerPrice > marketPrices.indexTokenPrice.min) {
        tp = orders[i].numbers.triggerPrice;
      } else {
        sl = orders[i].numbers.triggerPrice;
      }
      unchecked {
        i = i + 1;
      }
    }
    
    bytes32 accountOrderListKey = keccak256(abi.encode(keccak256(abi.encode("ACCOUNT_ORDER_LIST")), address(gmxUtils)));
    bytes32[] memory orderKeys = IDataStore(gDataStore).getBytes32ValuesAt(accountOrderListKey, 0, 10);
    gmxUtils.cancelOrder(orderKeys);
    return (sl, tp);
  }

  function _withdraw(address to, address recipient, uint256 _shares, bool forced, uint256 amount) internal returns (bool) {
    // get amount to withdraw from the estimated total hedgeAmount(balance + GMX liquidity)
    if (forced == false) {
      amount = _totalValue() * _shares / totalShares / marketPrices.shortTokenPrice.max;
    }
    uint256 balance = collateralToken.balanceOf(address(this));
    if (forced || balance >= amount ) {
      if (amount > initialDeposit[to]) {
        uint256 fee = (amount - initialDeposit[to]) * governanceFee / BASIS_POINTS_DIVISOR;
        collateralToken.safeTransfer(manager.treasury(), fee);
        collateralToken.safeTransfer(recipient, amount - fee);
      } else {
        collateralToken.safeTransfer(recipient, amount);
      }
      
      balance = balance - amount;
      _issueShares(to, _shares, false);
      return true;
    }

    // if we don't have enough balance, need to withdraw from GMX
    //  when decreasing position, we can't indicate amount of collateral token to withdraw using collateralDelta
    //   because `swapFee` and `closeFee` would be deducted from `amountOut`. it may need to multiply 1.01. should check exact multiplier value via testing
    uint256 want = amount - balance;
    IGmxUtils.PositionData memory positionData = gmxUtils.getPositionInfo(curPositionKey, marketPrices);
    uint256 sizeDelta;
    uint256 collateralDelta;
    if (want * marketPrices.shortTokenPrice.min >= positionData.netValue) {
      sizeDelta = positionData.sizeInUsd;
      collateralDelta = 0;
    } else {
      //  may need to consider fee deduction
      sizeDelta = want * marketPrices.shortTokenPrice.min * positionData.sizeInUsd / positionData.netValue;   //  want * size / netValue
      collateralDelta = positionData.collateralAmount * sizeDelta / positionData.sizeInUsd;
    }

    nextAction.selector = NextActionSelector.DECREASE_WITHDRAW_ACTION;
    bytes memory withdrawActionData = abi.encode(to, recipient, _shares, true, amount);
    nextAction.data = abi.encode(collateralDelta, sizeDelta, beenLong, withdrawActionData);
    return false;
  }

  // this is a temporary function for development
  function withdraw(address token) external onlyOwner {
    uint256 balance = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransfer(msg.sender, balance);
  }

  /**
   * @notice
   *  check available liquidity before create positions
   */
  // function _checkPool(bool _isLong, address _indexToken, address _tokenIn, uint256 sizeDelta) internal view {
  //   uint256 maxReservedUsd = getMaxReservedUsd(market, isLong);
  //   uint256 availableTokens = gVault.poolAmounts(_tokenIn) - gVault.reservedAmounts(_tokenIn);
  //   require(sizeDelta < gVault.tokenToUsdMin(_tokenIn, availableTokens), "max longs / shorts exceeded");
    
  //   if (_isLong) {
  //     uint256 maxGlobalLongSize = IPositionRouter(gPositionRouter).maxGlobalLongSizes(_indexToken);
  //     if (maxGlobalLongSize != 0) {
  //       require(
  //         gVault.guaranteedUsd(_indexToken) + sizeDelta < maxGlobalLongSize,
  //         "max longs exceeded"
  //       );
  //     }
  //   } else {
  //     uint256 maxGlobalShortSize = IPositionRouter(gPositionRouter).maxGlobalShortSizes(_indexToken);
  //     if (maxGlobalShortSize != 0) {
  //       require(
  //         gVault.globalShortSizes(_indexToken) + sizeDelta < maxGlobalShortSize,
  //         "max shorts exceeded"
  //       );
  //     }
  //   }
  // }
}

