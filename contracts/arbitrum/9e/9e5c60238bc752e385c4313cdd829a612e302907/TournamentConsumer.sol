// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.17;

import { ITournamentConsumer } from "./ITournamentConsumer.sol";
import { VRFConsumerBaseV2 } from "./VRFConsumerBaseV2.sol";
import { VRFCoordinatorV2Interface } from "./VRFCoordinatorV2Interface.sol";
import { ConfirmedOwner } from "./ConfirmedOwner.sol";

/**
 *
 * Randomness
 * - Trading is divided into 30 minute epochs (e)
 * - Random number is generated by chainlink VRF
 * - Every 30 minutes a public function update() can be called
 * - update() has a e/120 chance of ending a round
 * - As e increases, the chance of the round ending also increases
 * - p(e) = 1 - Î£(n = 0, e) ( (120 - e) / 120 )
 * - Epoch (e), minutes (t), probability (p)
 *  |----------------|
 *  |  e    t    p   |
 *  |----------------|
 *  |  0    0   0.00 |
 *  |  1    30  0.01 | ~ 1% chance round has ended
 *  |  2    60  0.02 |
 *  |  3    90  0.05 |
 *  |  4    120 0.08 |
 *  |  5    150 0.12 |
 *  |  6    180 0.16 |
 *  |  7    210 0.21 |
 *  |  8    240 0.26 | ~25% chance round has ended
 *  |  9    270 0.32 |
 *  | 10    300 0.38 |
 *  | 11    330 0.43 |
 *  | 12    360 0.49 | ~50% chance round has ended
 *  | 13    390 0.55 |
 *  | 14    420 0.60 |
 *  | 15    450 0.65 |
 *  | 16    480 0.70 |
 *  | 17    510 0.74 | ~75% chance round had ended
 *  | 18    540 0.78 |
 *  | 19    570 0.81 |
 *  | 20    600 0.84 |
 *  | 21    630 0.87 |
 *  | 22    660 0.90 |
 *  | 23    690 0.92 |
 *  | 24    720 0.93 |
 *  | 25    750 0.95 |
 *  | 26    780 0.96 |
 *  | 27    810 0.97 |
 *  | 28    840 0.97 |
 *  | 29    870 0.98 |
 *  | 30    900 0.99 | ~99% chance round has ended
 *  |----------------|
 * 
 **/
contract TournamentConsumer is VRFConsumerBaseV2, ConfirmedOwner, ITournamentConsumer {

    // HARDCODED FOR MUMBAI
    address constant COORDINATOR_ADDRESS = 0xAE975071Be8F8eE67addBC1A82488F1C24858067;

    // Chainlink VRF Parameters. See: https://docs.chain.link/vrf/v2/subscription/supported-networks
    VRFCoordinatorV2Interface public coordinator;

    // 500 GWEI POLYGON
    // bytes32 public keyHash = 0xcc294a196eeeb44da2888d17c0625cc88d70d9760a69d58d853ba6581a9ab0cd;
    
    // 30 GWEI ARBITRUM
    bytes32 public keyHash = 0x72d2b016bb5b62912afea355ebf33b91319f828738b111b723b78696b9847b63;

    // POLYGON
    // uint64 public subscriptionId = ;

    // ARBITRUM
    uint64 public subscriptionId = 88;

    // other config variables
    uint32 public callbackGasLimit = 2499999;
    uint32 public numWords = 1;
    uint16 public requestConfirmations = 3;

    // time interval storage
    bool public isActive;
    uint256 public intervalId;
    uint256 public maxEpoch;
    uint256 public epochTime;
    uint256 public lastEpochFilled;
    uint256 public startTime;
    uint256 public delay;

    event RequestSent(uint256 requestId, uint32 numWords);
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);

    constructor(
        uint64 _subscriptionId,
        address _coordinator
    ) 
        VRFConsumerBaseV2(_coordinator)
        ConfirmedOwner(msg.sender) 
    {
        coordinator = VRFCoordinatorV2Interface(_coordinator);
        subscriptionId = _subscriptionId;
        maxEpoch = 40;
        epochTime = 30 minutes;
        delay = 10 hours;
    }

    // @dev set delay before starting
    function setDelay(uint256 newDelay) external onlyOwner {
        delay = newDelay;
    }

    function setEpochTime(uint256 newEpochTime) external onlyOwner {
        require(newEpochTime >= 1 minutes, "epoch time must be above 1 minutes");
        epochTime = newEpochTime;
    }

    // @dev set subscription ID
    function setSubscriptionId(uint64 _subscriptionId) external onlyOwner {
        subscriptionId = _subscriptionId;
    }

    // @dev set subscription ID
    function setCallbackGasLimit(uint32 _callbackGasLimit) external onlyOwner {
        callbackGasLimit = _callbackGasLimit;
    }

    // @dev set coordinator
    function setCoordinator(address _coordinator) external onlyOwner {
        coordinator = VRFCoordinatorV2Interface(_coordinator);
    }

    // @dev set key hash
    function setkeyHash(bytes32 _keyHash) external onlyOwner {
        keyHash = _keyHash;
    }

    // @dev set key hash
    function setRequestConfirmations(uint16 _requestConfirmations) external onlyOwner {
        requestConfirmations = _requestConfirmations;
    }

    // @dev start interval
    function start() internal virtual {
        require(!isActive, "VRF start: already active.");
        lastEpochFilled = 0;
        startTime = block.timestamp;
        isActive = true;
    }

    // stop interval
    function stop() internal virtual {
        require(isActive, "VRF stop: not active.");
        isActive = false;
        intervalId++;
    }

    // @dev request a random number if current epoch has not been filled
    function update() public {
        require(isActive, "VRF update: must be active.");
        require(currentEpoch() > lastEpochFilled, "VRF update: current epoch already filled.");

        // contractors required me to do this:

        // Will revert if subscription is not set and funded.
        uint256 requestId = coordinator.requestRandomWords(
           keyHash,
           subscriptionId,
           requestConfirmations,
           callbackGasLimit,
            numWords
        );

        lastEpochFilled = currentEpoch();
        emit RequestSent(requestId, numWords);
    }

    // @dev return current epoch
    function currentEpoch() public view returns (uint256) {
        if (!isActive) { return 0; }
        if (block.timestamp < startTime + delay) { return 0; }
        return (block.timestamp - startTime - delay) / epochTime;
    }

    // @dev return if update is possible
    function canUpdate() public view returns (bool) {
        return currentEpoch() > lastEpochFilled;
    }

    // @dev Chainlink callback function
    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
        uint256 value = _randomWords[0] % maxEpoch;
        lastEpochFilled = currentEpoch();
        if(value <= currentEpoch() || currentEpoch() == maxEpoch) {
            stop();
        }
        emit RequestFulfilled(_requestId, _randomWords);
    }
}

