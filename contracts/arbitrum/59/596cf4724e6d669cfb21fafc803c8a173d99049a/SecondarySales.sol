pragma solidity >=0.7.0 <0.9.0;
// SPDX-License-Identifier: MIT

/**
 * Generated by : https://www.cues.sg
 * Cues.sg : We make technology accessible.
 * Contract Type : SecondarySales
*/
/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */
interface IERC721Receiver {
	/**
	 * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
	 * by `operator` from `from`, this function is called.
	 *
	 * It must return its Solidity selector to confirm the token transfer.
	 * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
	 *
	 * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
	 */
	function onERC721Received(
		address operator,
		address from,
		uint256 tokenId,
		bytes calldata data
	) external returns (bytes4);
}

interface ERC20{
	function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface ERC721{
	function balanceOf(address owner) external view returns (uint256);
	function safeTransferFrom(address from, address to, uint256 tokenId) external;
	function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);
}

contract SecondarySales {

	address owner;
	uint256 public taxRate = uint256(10000);
	struct NFTRecord { address depositorAddress; uint256 salesPrice; }
	mapping(uint256 => NFTRecord) public tokenRecord;

	constructor() {
		owner = msg.sender;
	}

	//This function allows the owner to specify an address that will take over ownership rights instead. Please double check the address provided as once the function is executed, only the new owner will be able to change the address back.
	function changeOwner(address _newOwner) public onlyOwner {
		owner = _newOwner;
	}

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}	

	function onERC721Received( address, address, uint256, bytes calldata ) public pure returns (bytes4) {
		return this.onERC721Received.selector;
	}

/**
 * Function changeValueOf_taxRate
 * Notes for _taxRate : 10000 is one percent
 * The function takes in 1 variable, (zero or a positive integer) _taxRate. It can only be called by functions outside of this contract. It does the following :
 * checks that the function is called by the owner of the contract
 * checks that 0 is strictly less than _taxRate
 * checks that 1000000 is strictly greater than _taxRate
 * updates taxRate as _taxRate
*/
	function changeValueOf_taxRate(uint256 _taxRate) external onlyOwner {
		require((uint256(0) < _taxRate), "Tax rate needs to be larger than 0%");
		require((uint256(1000000) > _taxRate), "Tax rate needs to be smaller than 100%");
		taxRate  = _taxRate;
	}

/**
 * Function putUpNFTForSale
 * The function takes in 2 variables, (zero or a positive integer) tokenId, and (zero or a positive integer) salesPrice. It can be called by functions both inside and outside of this contract. It does the following :
 * calls ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at safeTransferFrom function  with variable sender as (the address that called this function), variable recipient as (the address of this contract), variable amount as tokenId
 * creates an internal variable thisRecord with initial value Struct comprising (the address that called this function), salesPrice
 * updates tokenRecord (Element tokenId) as thisRecord
*/
	function putUpNFTForSale(uint256 tokenId, uint256 salesPrice) public {
		ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).safeTransferFrom(msg.sender, address(this), tokenId);
		NFTRecord memory thisRecord = NFTRecord (msg.sender, salesPrice);
		tokenRecord[tokenId]  = thisRecord;
	}

/**
 * Function purchaseNFT
 * The function takes in 1 variable, (zero or a positive integer) tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value tokenRecord with element tokenId
 * calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (thisRecord with element depositorAddress), variable amount as (((thisRecord with element salesPrice) * ((1000000) - (taxRate))) / (1000000))
 * calls ERC20(Address 0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)'s at transferFrom function  with variable sender as (the address that called this function), variable recipient as (the owner of this contract), variable amount as ((thisRecord with element salesPrice) - (((thisRecord with element salesPrice) * ((1000000) - (taxRate))) / (1000000)))
 * calls ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at safeTransferFrom function  with variable sender as (the address of this contract), variable recipient as (the address that called this function), variable amount as tokenId
 * updates tokenRecord (Element tokenId) as Struct comprising Address 0x0000000000000000000000000000000000000000000000000000000000000000, 0
*/
	function purchaseNFT(uint256 tokenId) public {
		NFTRecord memory thisRecord = tokenRecord[tokenId];
		ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transferFrom(msg.sender, thisRecord.depositorAddress, ((thisRecord.salesPrice * (uint256(1000000) - taxRate)) / uint256(1000000)));
		ERC20(address(0xdE70AeD3d14d39b4955147EfcF272334bdB75AB5)).transferFrom(msg.sender, owner, (thisRecord.salesPrice - ((thisRecord.salesPrice * (uint256(1000000) - taxRate)) / uint256(1000000))));
		ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).safeTransferFrom(address(this), msg.sender, tokenId);
		tokenRecord[tokenId]  = NFTRecord (address(0x0000000000000000000000000000000000000000000000000000000000000000), uint256(0));
	}

/**
 * Function ownerWithdrawNFTFromSale
 * The function takes in 1 variable, (zero or a positive integer) tokenId. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value tokenRecord with element tokenId
 * checks that (thisRecord with element depositorAddress) is equals to (the address that called this function)
 * calls ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at safeTransferFrom function  with variable sender as (the address of this contract), variable recipient as (the address that called this function), variable amount as tokenId
 * updates tokenRecord (Element tokenId) as Struct comprising Address 0x0000000000000000000000000000000000000000000000000000000000000000, 0
*/
	function ownerWithdrawNFTFromSale(uint256 tokenId) public {
		NFTRecord memory thisRecord = tokenRecord[tokenId];
		require((thisRecord.depositorAddress == msg.sender), "Only owner can withdraw");
		ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).safeTransferFrom(address(this), msg.sender, tokenId);
		tokenRecord[tokenId]  = NFTRecord (address(0x0000000000000000000000000000000000000000000000000000000000000000), uint256(0));
	}

/**
 * Function ownerChangePriceOfNFT
 * The function takes in 2 variables, (zero or a positive integer) tokenId, and (zero or a positive integer) salesPrice. It can be called by functions both inside and outside of this contract. It does the following :
 * creates an internal variable thisRecord with initial value tokenRecord with element tokenId
 * checks that (thisRecord with element depositorAddress) is equals to (the address that called this function)
 * updates tokenRecord (Element tokenId) (Entity salesPrice) as salesPrice
*/
	function ownerChangePriceOfNFT(uint256 tokenId, uint256 salesPrice) public {
		NFTRecord memory thisRecord = tokenRecord[tokenId];
		require((thisRecord.depositorAddress == msg.sender), "Only owner can change price");
		tokenRecord[tokenId].salesPrice  = salesPrice;
	}

/**
 * Function numberOfAvailableNFTs
 * The function takes in 0 variables. It can be called by functions both inside and outside of this contract. It does the following :
 * returns ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at balanceOf function  with variable recipient as (the address of this contract) as output
*/
	function numberOfAvailableNFTs() public view returns (uint256) {
		return ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).balanceOf(address(this));
	}

/**
 * Function tokenIdOfEachAvailableNFT
 * The function takes in 1 variable, (zero or a positive integer) _whichId. It can be called by functions both inside and outside of this contract. It does the following :
 * returns ERC721(Address 0x3C470482066F2949Ecc745630250D50809cD0A27)'s at tokenOfOwnerByIndex function  with variable sender as (the address of this contract), variable index as _whichId as output
*/
	function tokenIdOfEachAvailableNFT(uint256 _whichId) public view returns (uint256) {
		return ERC721(address(0x3C470482066F2949Ecc745630250D50809cD0A27)).tokenOfOwnerByIndex(address(this), _whichId);
	}
}