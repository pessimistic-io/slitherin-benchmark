/*
https://www.nitrofrens.wtf
Join the Biggest and Frenliest Army any Chain as seen!
╭━╮╱╭╮╭╮╱╱╱╱╱╱╭━━━╮╱╱╱╱╱╱╱╱╱╱╱╭━━━╮
┃┃╰╮┃┣╯╰╮╱╱╱╱╱┃╭━━╯╱╱╱╱╱╱╱╱╱╱╱┃╭━╮┃
┃╭╮╰╯┣╮╭╋━┳━━╮┃╰━━┳━┳━━┳━╮╭━━╮┃┃╱┃┣━┳╮╭┳╮╱╭╮
┃┃╰╮┃┣┫┃┃╭┫╭╮┃┃╭━━┫╭┫┃━┫╭╮┫━━┫┃╰━╯┃╭┫╰╯┃┃╱┃┃
┃┃╱┃┃┃┃╰┫┃┃╰╯┃┃┃╱╱┃┃┃┃━┫┃┃┣━━┃┃╭━╮┃┃┃┃┃┃╰━╯┃
╰╯╱╰━┻┻━┻╯╰━━╯╰╯╱╱╰╯╰━━┻╯╰┻━━╯╰╯╱╰┻╯╰┻┻┻━╮╭╯
╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╭━╯┃
╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╰━━╯
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⣿⠽⠭⣥⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠞⠉⠁⠀⠀⠀⠀⠉⠉⠛⠶⣤⣀⠀⠀⢀⣤⠴⠞⠛⠉⠉⠉⠛⠶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡾⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⣏⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠀⠀⠀⠀⢀⣠⠤⠤⠤⠤⢤⣄⡀⠀⠀⠹⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠐⠈⠁⠀⠀⠀⠀⠀⠀⠀⠉⠛⠶⢤⣽⡦⠐⠒⠒⠂⠀⠀⠀⠀⠐⠒⠀⢿⣦⣀⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢀⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡤⠤⠤⠤⠤⠠⠌⢻⣆⡀⠀⠀⠀⣀⣀⣀⡀⠤⠤⠄⠠⢉⣙⡿⣆⡀⠀
⠀⠀⠀⠀⣀⣴⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⢶⣛⣩⣶⣶⡾⢯⠿⠷⣖⣦⣤⣍⣿⣴⠖⣋⠭⣷⣶⣶⡶⠒⠒⣶⣒⣠⣀⣙⣿⣆
⠀⠀⢀⠞⠋⠀⡇⠀⠀⠀⠀⠀⠀⢀⣠⡶⣻⡯⣲⡿⠟⢋⣵⣛⣾⣿⣷⡄⠀⠈⠉⠙⠛⢻⣯⠤⠚⠋⢉⣴⣻⣿⣿⣷⣼⠁⠉⠛⠺⣿
⠀⣠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣟⣫⣿⠟⠉⠀⠀⣾⣿⣻⣿⣤⣿⣿⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⣿⣿⣻⣿⣼⣿⣿⠇⠀⠀⠀⢙
⢠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⡶⣄⠀⠀⢻⣿⣿⣿⣿⣿⡏⠀⠀⠀⣀⣤⣾⣁⠀⠀⠀⠸⢿⣿⣿⣿⡿⠋⠀⣀⣠⣶⣿
⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠺⢿⣶⣶⣮⣭⣭⣭⣭⡴⢶⣶⣾⠿⠟⠋⠉⠉⠙⠒⠒⠊⠉⠈⠉⠚⠉⠉⢉⣷⡾⠯
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠀⠀⠀⢈⣽⠟⠁⠀⠀⠀⠀⣄⡀⠀⠀⠀⠀⠀⠀⢀⣴⡾⠟⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⡴⠞⠋⠁⠀⠀⠀⠀⠀⠀⠈⠙⢷⡀⠉⠉⠉⠀⠙⢿⣵⡄⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⡀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⠟⠋⠉⠀⠀⠉⠛⠛⠛⠛⠷⠶⠶⠶⠶⠤⢤⣤⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣠⡤⢿⣆⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡶⠋⠀⠀⠀⠸⠿⠛⠛⠛⠓⠒⠲⠶⢤⣤⣄⣀⠀⠀⠀⠈⠙⠛⠛⠛⠛⠒⠶⠶⠶⣶⠖⠛⠛⠁⢠⣸⡟⠀
⠀⠀⠀⠀⠀⠀⢰⣆⠀⢸⣧⣤⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠓⠒⠲⠦⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣾⠋⠀⠀
⡀⠀⠀⠀⠀⠀⠀⠙⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠉⠛⠲⠶⣶⣤⣄⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡾⠃⠀⠀⠀
⣿⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠛⠛⣳⣶⡶⠟⠉⠀⠀⠀⠀⠀
⠛⢷⣿⣷⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠈⠙⠻⢷⣬⣗⣒⣂⡀⠠⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣤⡴⠾⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠛⠿⠶⠶⠶⠶⣤⣤⣭⣭⣍⣉⣉⣀⣀⣀⣀⣼⣯⡽⠷⠿⠛⠙⠿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠈⠻⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

// SPDX-License-Identifier: MIT
 prettier-ignore */
pragma solidity ^0.8.4;

import "./ERC721A.sol";
import "./Ownable.sol";
import "./ReentrancyGuard.sol";
import "./strings.sol";

interface IFren {
    function balanceOf(address) external view returns (uint256);

    function enableTrading() external returns (bool);

    function transfer(address to, uint256 amount) external returns (bool);
}

contract FrensArmy is ERC721A, Ownable, ReentrancyGuard {
    string public _baseTokenURI =
        "https://bafybeienyryfasf5pfaoi7reamiwhpq3ndp2jknam2dsxzvn5lqzimf5mm.ipfs.nftstorage.link/";
    using Strings for uint256;
    uint256 public maxSupply = 420;
    bool public saleIsActive = true;
    address NFAERC20;
    string public uriPrefix = "";
    string public uriSuffix = ".json";

    uint256 public FREN_PRICE = 0.015 ether;
    uint256 public BASE_PRICE = 0.027 ether;

    uint256 public total_GM = 0;
    uint256 public gm_Burn = 30;
    uint256 public MaxFren = 69;
    uint256 public PromoMints = 0;

    uint256 public _gmTime = 12 hours;
    uint256 public burnReward = 69000;
    bool public openERC20 = false;

    mapping(address => uint256) public user_GM;
    mapping(address => uint256) public gmCooldown;
    mapping(address => bool) public isoriginalFren;
    mapping(address => bool) public _hasBurned;

    address internal constant fren_grave = 0x000000000000000000000000000000000000dEaD;
    address internal constant partyHat_address = 0x69b2cd28B205B47C8ba427e111dD486f9C461B57;
    address internal constant kektribe_address = 0x58EA7917F74834dbE6b57D0a2a74fb68C1e94c55;

    constructor() ERC721A("Nitro Frens Army", "NFA") {}

    /** ADMIN */
    /// @dev reduce total supply
    /// @param newMaxSupply new total supply must be inferior to previous
    function reduceTotalSupply(uint256 newMaxSupply) public onlyOwner {
        maxSupply = newMaxSupply;
    }

    /// @dev change the base uri
    /// @param uri base uri
    function setTokenURI(string memory uri) public onlyOwner {
        _baseTokenURI = uri;
    }

    /// @dev Pause sale if active, make active if paused
    function flipSaleState() public onlyOwner {
        saleIsActive = !saleIsActive;
    }

    /**
     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
     * by default, can be overriden in child contracts.
     */
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory currentBaseURI = _baseTokenURI;
        return
            bytes(currentBaseURI).length > 0
                ? string(abi.encodePacked(currentBaseURI, _tokenId.toString(), uriSuffix))
                : "";
    }

    function setFrensAddress(address frens) external onlyOwner {
        NFAERC20 = frens;
    }

    function _isEligible(address user) public view returns (bool) {
        if (IFren(partyHat_address).balanceOf(user) > 0 || IFren(kektribe_address).balanceOf(user) > 0) return true;
        else return false;
    }

    /// @dev mint number of nfts

    function mintFren() public payable nonReentrant returns (uint256) {
        require(saleIsActive, "Sale must be active to mint");
        require(totalSupply() < maxSupply, "Purchase exceeds max supply");
        require(msg.value >= userMintPrice(msg.sender), "pls attach 0.0222 ether per fren");

        _safeMint(msg.sender, 1);

        if (totalSupply() >= MaxFren && !openERC20) {
            IFren(NFAERC20).enableTrading();
            openERC20 = true;
        }
        if (!openERC20) {
            isoriginalFren[msg.sender] = true;
        }
        return totalSupply();
    }

    function teamMinting(address _address, uint256 amount) public onlyOwner {
        uint256 totaltickets = totalSupply();
        require(totaltickets + amount < maxSupply, "Purchase exceeds max supply");
        _safeMint(_address, amount);
        isoriginalFren[msg.sender] = true;
    }

    /// @dev mint number of nfts

    function mint_promo() public payable nonReentrant returns (uint256) {
        require(saleIsActive, "Sale must be active to mint");
        require(totalSupply() < maxSupply, "Purchase exceeds max supply");
        require(_isEligible(msg.sender), "You Don't own any of the frens tokens");
        if (PromoMints > 6) {
            require(msg.value >= FREN_PRICE, "pls attach 0.015 ether per ticket fren");
        }

        _safeMint(msg.sender, 1);
        if (totalSupply() >= MaxFren && !openERC20) {
            IFren(NFAERC20).enableTrading();
            openERC20 = true;
        }
        if (!openERC20) {
            isoriginalFren[msg.sender] = true;
        }
        PromoMints++;
        return totalSupply();
    }

    function userMintPrice(address user) public view returns (uint256) {
        uint256 mintprice = (BASE_PRICE * (100 - 15 * user_GM[user])) / 100;
        if (mintprice > FREN_PRICE) return mintprice;
        else return FREN_PRICE;
    }

    function _canGM(address _user) public view returns (bool) {
        if (gmCooldown[_user] < block.timestamp) return true;
        else return false;
    }

    function gmToMint() public nonReentrant {
        require(_canGM(msg.sender), "Must wait 12 hours before saying GM");
        user_GM[msg.sender]++;
        total_GM++;
        gmCooldown[msg.sender] = block.timestamp + _gmTime;
    }

    function updatePrices(uint256 _frenPrice, uint256 _basePrice, uint256 _burnReward) external onlyOwner {
        FREN_PRICE = _frenPrice;
        BASE_PRICE = _basePrice;
        burnReward = _burnReward;
    }

    function updateConstants(uint256 _maxfren, uint256 _gm_Burn) external onlyOwner {
        MaxFren = _maxfren;
        gm_Burn = _gm_Burn;
    }

    function burnFren(uint256 bellId) public nonReentrant {
        require(!_hasBurned[msg.sender], "You Have already burned one fren");
        require(user_GM[msg.sender] > gm_Burn, "You didnt say GM enough times");
        require(isoriginalFren[msg.sender], "Onli OG frens ken bUrn");

        require(IFren(NFAERC20).balanceOf(address(this)) > burnReward, "No more $NFA to give");
        _burn(bellId);
        _hasBurned[msg.sender] = true;
        IFren(NFAERC20).transfer(msg.sender, burnReward);
    }

    function setUriSuffix(string memory _uriSuffix) public onlyOwner {
        uriSuffix = _uriSuffix;
    }

    function frensFundus() public payable onlyOwner {
        (bool success, ) = payable(msg.sender).call{value: address(this).balance}("");
        require(success);
    }

    function somethingAboutTokens(address token) external onlyOwner {
        uint256 balance = IFren(token).balanceOf(address(this));
        IFren(token).transfer(msg.sender, balance);
    }
}

