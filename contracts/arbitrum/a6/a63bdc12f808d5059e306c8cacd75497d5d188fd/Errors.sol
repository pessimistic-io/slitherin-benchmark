// SPDX-License-Identifier: GPL-3.0-or-later
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.8.17;

// solhint-disable

/**
 * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are
 * supported.
 * Uses the default 'UNW' prefix for the error code
 */
function _require(bool condition, uint256 errorCode) pure {
  if (!condition) _revert(errorCode);
}

/**
 * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are
 * supported.
 */
function _require(bool condition, uint256 errorCode, bytes3 prefix) pure {
  if (!condition) _revert(errorCode, prefix);
}

/**
 * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
 * Uses the default 'UNW' prefix for the error code
 */
function _revert(uint256 errorCode) pure {
  _revert(errorCode, 0x554e57); // This is the raw byte representation of "UNW"
}

/**
 * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.
 */
function _revert(uint256 errorCode, bytes3 prefix) pure {
  uint256 prefixUint = uint256(uint24(prefix));
  // We're going to dynamically create a revert string based on the error code, with the following format:
  // 'UNW#{errorCode}'
  // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).
  //
  // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a
  // number (8 to 16 bits) than the individual string characters.
  //
  // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a
  // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a
  // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.
  assembly {
    // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999
    // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for
    // the '0' character.

    let units := add(mod(errorCode, 10), 0x30)

    errorCode := div(errorCode, 10)
    let tenths := add(mod(errorCode, 10), 0x30)

    errorCode := div(errorCode, 10)
    let hundreds := add(mod(errorCode, 10), 0x30)

    // With the individual characters, we can now construct the full string.
    // We first append the '#' character (0x23) to the prefix. In the case of 'UNW', it results in 0x554e57 ('UNW#')
    // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the
    // characters to it, each shifted by a multiple of 8.
    // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits
    // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte
    // array).
    let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))

    let revertReason := shl(
      200,
      add(formattedPrefix, add(add(units, shl(8, tenths)), shl(16, hundreds)))
    )

    // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded
    // message will have the following layout:
    // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]

    // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We
    // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.
    mstore(
      0x0,
      0x08c379a000000000000000000000000000000000000000000000000000000000
    )
    // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).
    mstore(
      0x04,
      0x0000000000000000000000000000000000000000000000000000000000000020
    )
    // The string length is fixed: 7 characters.
    mstore(0x24, 7)
    // Finally, the string itself is stored.
    mstore(0x44, revertReason)

    // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of
    // the encoded message is therefore 4 + 32 + 32 + 32 = 100.
    revert(0, 100)
  }
}

function _verifyCallResult(
  bool success,
  bytes memory returndata
) pure returns (bytes memory) {
  if (success) {
    return returndata;
  }
  if (returndata.length > 0) {
    // solhint-disable-next-line no-inline-assembly
    assembly {
      let returndata_size := mload(returndata)
      revert(add(32, returndata), returndata_size)
    }
  }
  _revert(Errors.SHOULD_NOT_HAPPEN);
}

library Errors {
  // Math
  uint256 internal constant ADD_OVERFLOW = 0;
  uint256 internal constant SUB_OVERFLOW = 1;
  uint256 internal constant SUB_UNDERFLOW = 2;
  uint256 internal constant MUL_OVERFLOW = 3;
  uint256 internal constant ZERO_DIVISION = 4;
  uint256 internal constant DIV_INTERNAL = 5;
  uint256 internal constant X_OUT_OF_BOUNDS = 6;
  uint256 internal constant Y_OUT_OF_BOUNDS = 7;
  uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;
  uint256 internal constant INVALID_EXPONENT = 9;

  // Input
  uint256 internal constant OUT_OF_BOUNDS = 10;
  uint256 internal constant UNSORTED_ARRAY = 11;
  uint256 internal constant UNSORTED_TOKENS = 12;
  uint256 internal constant INPUT_LENGTH_MISMATCH = 13;
  uint256 internal constant INVALID_INPUT = 14;

  // TradingBook related
  uint256 internal constant ZERO_TOKEN = 104;
  uint256 internal constant TOKEN_MISMATCH = 105;
  uint256 internal constant INVALID_STOP_LOSS = 106;
  uint256 internal constant INVALID_PROFIT_TARGET = 107;
  uint256 internal constant FEE_TOO_HIGH = 108;
  uint256 internal constant NEGATIVE_LEVERAGE = 109;
  uint256 internal constant LEVERAGE_TOO_HIGH = 110;
  uint256 internal constant APPROVED_PRICE_ID_ONLY = 111;
  uint256 internal constant POSITION_TOO_SMALL = 112;
  uint256 internal constant SLIPPAGE_TOO_GREAT = 113;
  uint256 internal constant SLIPPAGE_EXCEEDS_LIMIT = 114;
  uint256 internal constant SWAP_MARGIN_MISMATCH = 115;
  uint256 internal constant INVALID_CLOSE_PERCENT = 116;
  uint256 internal constant INVALID_MARGIN = 117;
  uint256 internal constant ORDER_NOT_FOUND = 118;
  uint256 internal constant TRADER_OWNER_MISMATCH = 119;
  uint256 internal constant POSITIVE_EXPO = 120;
  uint256 internal constant NEGATIVE_PRICE = 121;
  uint256 internal constant INVALID_BURN_AMOUNT = 122;
  uint256 internal constant NOTHING_TO_BURN = 123;
  uint256 internal constant INVALID_TOKEN_DECIMALS = 124;
  uint256 internal constant MIN_BIGGER_THAN_MAX = 125;
  uint256 internal constant MAX_SMALLER_THAN_MIN = 126;
  uint256 internal constant MIN_SMALLER_THAN_THRESHOLD = 127;
  uint256 internal constant BURN_EXCEEDS_EXCESS = 128;
  uint256 internal constant PRICE_ID_MISMATCH = 129;
  uint256 internal constant TRADE_DIRECTION_MISMATCH = 130;
  uint256 internal constant CANNOT_LIQUIDATE = 131;
  uint256 internal constant INVALID_TIMESTAMP = 132;
  uint256 internal constant CANNOT_EXECUTE_LIMIT = 133;
  uint256 internal constant INVALID_FEE_FACTOR = 134;
  uint256 internal constant INVALID_MINT_AMOUNT = 135;
  uint256 internal constant TRADE_SALT_MISMATCH = 136;
  uint256 internal constant REQUIRE_BURN_REQUEST = 137;

  // Access
  uint256 internal constant APPROVED_ONLY = 200;
  uint256 internal constant TRADING_PAUSED = 201;
  uint256 internal constant USER_OR_LIQUIDATOR_ONLY = 202;
  uint256 internal constant USER_SENDER_MISMATCH = 203;
  uint256 internal constant LIQUIDATOR_ONLY = 204;
  uint256 internal constant DELEGATE_CALL_ONLY = 205;
  uint256 internal constant TRANSFER_NOT_ALLOWED = 206;
  uint256 internal constant APPROVED_TOKEN_ONLY = 207;
  uint256 internal constant ZERO_ADDRESS = 208;

  // Trading capacity
  uint256 internal constant MAX_OPEN_TRADES_PER_PRICE_ID = 300;
  uint256 internal constant MAX_OPEN_TRADES_PER_USER = 301;
  uint256 internal constant MAX_MARGIN_PER_USER = 302;
  uint256 internal constant MAX_LIQUIDITY_POOL = 303;
  uint256 internal constant MAX_TOTAL_POSITIONS = 304;

  // Pyth related
  uint256 internal constant INVALID_UPDATE_DATA_SOURCE = 400;
  uint256 internal constant INVALID_UPDATE_DATA = 401;
  uint256 internal constant INVALID_WORMHOLE_VAA = 402;
  uint256 internal constant PRICE_FEED_NOT_FOUND = 403;

  // Referral
  uint256 internal constant USER_ALREADY_REGISTERED = 500;
  uint256 internal constant INVALID_REFERRAL_CODE = 501;
  uint256 internal constant USER_NOT_REGISTERED = 502;
  uint256 internal constant INVALID_SHARE = 503;
  uint256 internal constant EXCEED_MAX_REFERRAL_CODES = 504;

  // NFT related
  uint256 internal constant ALREADY_MINTED = 600;
  uint256 internal constant MAX_MINTED = 601;
  uint256 internal constant INVALID_DISCOUNT = 602;

  // Staking related
  uint256 internal constant INVALID_AMOUNT = 700;
  uint256 internal constant INVALID_TOKEN_ID = 701;
  uint256 internal constant NO_STAKING_POSITION = 702;
  uint256 internal constant INVALID_REWARD_TOKEN = 703;
  uint256 internal constant ALREADY_STAKED = 704;

  // Airdrop related
  uint256 internal constant START_BLOCK_NOT_REACHED = 800;

  // Timelock related
  uint256 internal constant INVALID_AGREEMENT_CONTEXT = 900;
  uint256 internal constant BENEFICIARY_SENDER_MISMATCH = 901;
  uint256 internal constant RELEASE_TIME_NOT_REACHED = 902;
  uint256 internal constant AGREEMENT_FROZEN = 903;
  uint256 internal constant AGREEMENT_NOT_FROZEN = 904;

  // Misc
  uint256 internal constant CALL_FAILED = 1997;
  uint256 internal constant UNIMPLEMENTED = 1998;
  uint256 internal constant SHOULD_NOT_HAPPEN = 1999;
}

