// SPDX-License-Identifier: MIT
//
//                                                   ,                            
//             ,▓                              ,╓╗#▓▓▓╬╬╗@╦                      , 
//             ██⌐                          ,╔▓▓╣╬▓▓╬╬╬╬╣╬╬▓▒                  ▄██ 
//            ▐██▌                       ╔╬@╬╣▓▓╬╣▓▓▓╬╣╬╬╣▓▓╬▌                ▓███ 
//            ▐███                     ╔╬╬╬╬╬╣▓▓╣▓▓▓╬▓▓▓▓╣▓▓▓╬╬             ▄████  
//             ███▓                  ╒╣╣╬╬╬╬╬╣█╣▓▓▓╬▓▓╣▓╣▓▓▓▓▓▌            █████   
//             ╙████                @╣╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓╣█▓▓▓▓▓▓▌          ▄▓████▀    
//              ╟████▄     "╗,     ▓╬╬╬╬╬╬╬╣▓█▓█▓▓▓▓▓█▓▓▓▓▓▓▀         ▄██████`     
//               ▀████▓       ╙▀▄ ,▓▓▓▓▓▓▓╬╬█▓█▓█▓▓▓██▓▓▓█▓╙      ,▄▓██████▀       
//                ╙█████▓,       ╙█▓╬╬╣▓╬▓█▓╬███▓█▓██▓▓██▀     ,▄████████╨         
//     ,╔εσφφφφφMεε╦▓▓█████▄      ╫▓╬╬╬╣╣█▓█▓▓▓▓███████▀   ▄▓█████████▀            
//  @╬╬▓φφφφφφφ░░░░░░╙╙╚╚╩╬╬╬▀╗,  ╣▓╬╣╣╬▓▓▓╬╬╬╬╬╬╬▀▀▀╬╔≡▀▓▓███████▀▀               
//  └╫╬╬▒φφφφφ╦φφφ░░▒▒▒╠╬▓▒╚φ▒▒▒╠▓▓╣╬╬╬╣╣▓▓╨╚╬▒░░φ╣╬▌φ╦╦▒░░╙╙╚╙╚╩▒▒▒δφφ≥╔╓,        
//   ╘╬╬╬▒░░░φφφφφφ╗╣╬▒▒╩╠▒╣▒▒╬╬▓▓╬╬╠╠╬╣▓▓▓▒φδ▓▓▒φ░░░░▒╗▄φ░╙╙╚╚#φφφ░;░░░░╙╚╬╬▓ε    
//       ║╬╬▄φφφφ5░╙╫╬▒▄╗▒φ░▒▒▒▓▓╬╬╠╠╠╬╣╬▓▓▌5φ╙╚▒╙╚▒▒╩╢╩╚φφ░░╙╙êφφφ░░╙╚╚▒▒╣╬▀╨     
//       └╣╬╬"`"╚▒▒φ▒╙╙╠╫╬╦φê░╫▓╬╬╬╬╠╬╬╬╬▓▓▌╚φ╣▓▒░░╙╣▒φ╦▒5φ╥░╙Σφ╦░░░░▒▒╣▒╣╬╝       
//               ║╬╣▌▒▒░░φφδ░▒▓▓╬╬╬╬╬╬╬╣╬▓▓▌░φ░╙φ░╙δφ░╚╚╠▒▒╦▒╙Σ╦▄▒╚╣▓╣╝╝╨          
//                  ╝╬╣╣╬╣▒╩╣╣▓╣╬╬╬╬╣╣╬╬╣▓▓▓▓▄╬▒▒▄░▒▒░╟╣▒╚╚╣╬╬"╣╬╣  ╙              
//                       ╙    ╟▓╬╬╬╬╬╣╣╬▓▓████╜ ╙╝⌐└╙ ╙▀▀  └▀╜                     
//                             ▀███▓▓▓███████╨└                                    
//                               ╙██████████                                       
//                             m▓▓   └ └   ╙▄                                      
//                            `Å▐          j█▀≈ 
//
// ▄═╗▄m╗╕▓█▌           ═▄▄══▄▀█▌                            ▄▄ÆW▄ j█▌     ▐█▌
// ╙ ╫█▌ └╟█▌Æ█▄ ▄▓▀█µ   ██ ▄└▐█▌ ▄█▀▄,%█▌'██ ¥∩▄█▀▓,▄▓▄▓█  ██─  ╙ ▄▄▌a▄█▄█▐█▌,▄▀%▄
//   ╫█▌  ╟█▌j██▐██▀▀▀   ██¬▀ ▐█▌╟█▌ ██ ██▄╙█▄▌▐██▀▀▀╞█▌    ██⌐╙██▀▐█▌ ██  ▐█▌╙████
//  *╝▀▀⌐ ╝▀▀ª▀▀ ╙▀▀▀└  ═▀▀═  ╝▀▀ ▀▀4▀└  ▀┘ ╚▀  ╙▀▀▀─╧▀▀⌐    ╙▀W╝▀ ╝▀▀∞▀▀═ ╝▀▀╜▀═╝▀
//
// Venusian Flora created by Ryan Meyers @sreyeMnayR for The Flower Girls
// Twitter: @FlowerGirlsNFT  Web: https://flowergirlsnft.com
// 
//
// Generosity attracts generosity.
//
// The world will be saved by beauty.
//
// 
// ERC-1155 v2022.6.7
//

pragma solidity ^0.8.17;
pragma abicoder v2;


import "./IERC1155Receiver.sol";
import "./ERC1155URIStorage.sol";
import "./Address.sol";
import "./Context.sol";
import "./Ownable.sol";
import "./ERC2981.sol";
import "./ERC165.sol";
import "./EIP712.sol";
import "./ECDSA.sol";

import "./DateTime.sol";
import "./RevokableDefaultOperatorFilterer.sol";
import "./UpdatableOperatorFilterer.sol";

import "./IERC1155_VF.sol";
import "./IVenusianGarden_v0.sol";

contract ERC1155VF is IERC1155VF, Context, Ownable, EIP712, ERC2981, ERC1155URIStorage, RevokableDefaultOperatorFilterer {

  error InvalidClaimKey();
  error WalletNotSender();
  error NotForSale();
  error NotEnoughEth();
  error NotEnoughTokens();
  error LengthMismatch();
  error CannotTransferSoulbound();
  error NotEnoughAvailable();
  error AlreadyClaimed();

  struct FloraData {
    uint16 maxSupply;   //  0 + 16 = 16
    uint16 minted;      // 16 + 16 = 32
    uint16 supply;      // 32 + 16 = 48
    uint64 price;       // 48 + 64 = 112
    bool forSale;       // 112 + 8 = 120
    bool soulbound;     // 120 + 8 = 128
    uint16 planted;     // 128 + 16 = 144
  }

  struct ClaimKey {
      address wallet;
      uint tokenId;
      uint amount;
      uint claimId;
    }

    bytes32 private constant CLAIMKEY_TYPE_HASH = keccak256("ClaimKey(address wallet,uint tokenId,uint amount,uint claimId)");

    address private _signer;
    address private _bank;
    string public name = "Flower Girls Venusian Flora";
    string public symbol = "FLORA";

    address public venusianGardenContract;

  constructor(
      string memory uri_,
      string memory name_,
      string memory version_,
      address signer_,
      address bank_,
      address garden_
    )
      ERC1155(uri_)
      EIP712(name_, version_) 
    {
        _signer = signer_;
        _bank = bank_;
        venusianGardenContract = garden_;
        _setDefaultRoyalty(bank_, 1000);
    }
  
  // Check claim signature/key

  function checkClaim(bytes calldata signature, ClaimKey calldata key) public view returns (bool) {
    bytes32 digest = _hashTypedDataV4(
        keccak256(
            abi.encode(
                CLAIMKEY_TYPE_HASH,
                msg.sender,
                key.tokenId,
                key.amount,
                key.claimId
            )
        )
      );

      return ECDSA.recover(digest, signature) == _signer;
    }

  // Implement burnable methods 

  function burn(
        address account,
        uint256 id,
        uint256 value
    ) public virtual {
        require(
            account == _msgSender() || isApprovedForAll(account, _msgSender()),
            "ERC1155: caller is not token owner or approved"
        );

        _burn(account, id, value);
    }

    function burnBatch(
        address account,
        uint256[] memory ids,
        uint256[] memory values
    ) public virtual {
        require(
            account == _msgSender() || isApprovedForAll(account, _msgSender()),
            "ERC1155: caller is not token owner or approved"
        );

        _burnBatch(account, ids, values);
    }

    function setSigner(
      address signer_
    ) public onlyOwner {
      _signer = signer_;
    }

    function setURI(
      uint256 tokenId,
      string memory tokenURI
    ) public onlyOwner {
      _setURI(tokenId, tokenURI);
    }

    function setBaseURI(
      string memory baseURI
    ) public onlyOwner {
      _setBaseURI(baseURI);
    }

    // 

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC2981, ERC1155) returns (bool) {
        return ERC2981.supportsInterface(interfaceId) || 
          ERC1155.supportsInterface(interfaceId) ||
          super.supportsInterface(interfaceId);
    }

    // OpenSea bully clause

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 amount, bytes memory data)
        public
        override
        onlyAllowedOperator(from)
    {
        super.safeTransferFrom(from, to, tokenId, amount, data);
    }

    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override onlyAllowedOperator(from) {
        super.safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    function owner() public view virtual override (Ownable, UpdatableOperatorFilterer) returns (address) {
        return Ownable.owner();
    }

    function setDefaultRoyalty(address receiver, uint96 feeNumerator) public onlyOwner {
      _setDefaultRoyalty(receiver, feeNumerator);
    }

    function setBank(address bank_) public onlyOwner {
      _bank = bank_;
    }

    function withdraw() public payable {
      require(payable(_bank).send(address(this).balance));
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override virtual {
        if(venusianGardenContract != address(0)){
          IVenusianGarden(venusianGardenContract).respondToPlantTransfers(address(this), operator, from, to, ids, amounts, data);
        }
    }

  function boolToUint(bool x) public pure returns (uint r) {
    assembly { r := x }
  }
  function uintToBool(uint x) public pure returns (bool r) {
    assembly { r := gt(x,0) }
  }
  function uintToZeroOrOne(uint x) public pure returns (uint r) {
    r = boolToUint(uintToBool(x));
  }

}
