// SPDX-License-Identifier: MIT
//
//                                                                            .
//     ▌╝╨╨╨╨╙╙╩╙¬╙╙╙╙╙╙"""""^¬╙╙╙╨╙╨╜▀▀▀▀╝╝╝╝╝╝╝▀▀▀▀▀╩▀ΓΓΣÑÑÑÑÑ▀▀▀▀▀▀▀▀▀▀▀▀▀▀╟
//     ▌▌                                                               ^.   j▐
//     ▌▌                          ╔▒   ≈╖         ,@⌐                       j▐
//     ▌b                       « ,▓╠ ;,"▌-,      ╔╬"                        "▐⌐
//    .▌▌        ╚╦       -╔,`, ╓▄"╬╬▒╠▀▓╫▓Æ╣▓,   "                          -▐⌐
//     ▌Γ         ╙╣▓  ╓╗ ╙╬▓▌' ^╨∩╬╬╫  ║▓ ∩≈¬.,▄,▐▒ ▄,                       ▐ . .
//     ╫Γ            ╙ ╙▒╙▓▓ⁿQφ╟╬╟▓╝╬▌  ▓▌]░∩,ⁿ"│@╬▀╔▓▀m ╗▄           .       ▒░. '
//     ╫▌              ╠▀½╠╣▀╩\╚▒╠▒╔▄╙╬▓▓▓║░▒^   ╔▓"╙@▓▓╩                   ~ ▒▒`
//     ╫▌           .  `ⁿ, ╣╬ε╠Ç╬╬╬╠╬╟▐▓╬▀▀╬╩╢╬╬╬▓"Σ▀╬ ▓⌐[                    ▒▒
//     ╫▌          --╚╝╬╦▓▓▄╣▒╢▓╣╚╙╙""~╝▓╢╠≥"╚║╩╬╩  ╓╣▓▌/ ,▄[                '▒⌐
//  ~∩~╫▌         ,-~~╫╙╝╣╣∩╚╣▄╙╫╣╠╠╬▒ , ╒╠   ╠╩ ╓@╬▒,,[ ╗▄╩                  ▒⌐
//     ╫▌         ╣▓╝╬╬╗╬▌║▒▄, `╙` `.Γ╙]µε╩░>/«δ╬ ╬╬▓╬φ░▄▓▓Θ╟▀ ⁿ              ▒⌐
//     ╠Γ      »╓▌▓╠▄ç"╙╚▒░╙╙╠╜╔▒g╖╖æ\┐φφφQ╔`δ░  φ╠▒╬▓╬▀` ,╠╝╬⌐ ,             ▒
//     ╡Γ       ▓╬╬╠╫▒▒▒▒▒╬╬╬╙⌠╨╙.~░"└≥▒╠╫▓▒"-φ-,δ╬Γ▓▓╩ ,Γ▐▓▓▌▄▓▓             j⌐
//     ▌Γ         '╙▓▓▓▓▓▓▓▓╬▒╢╩", ╓M.>╚╝╩╩w=░"╙│╩,╢╩╠▄▄▄▄╠╚╝▌¬"              ▐
//     ▌▌            ╓╬▒╢╩╜╙╙╝╬φ ▒╠▒"≤∩ε\7]▒≥\≥╔φ╗╣╣▓╬╬╙"""²,▀╜  ,            ▐
//     ▌▌          ┌╣╩╠╩╔▒╠╬▓▓▒▒µ╬╩▒   ▒ {  ╠╦»╬╝╢▓╬▓╬╩╚╫▄½╗▄'-`│▄▓  "-      ]▐
// ^   ▌▌            *╠[ .»╚╙╝╩╠╬▓╨▒╝╓╚╬#Åδ╗▄╗╗▄▒╙╬╬╣▓╣▄╣▓▄▀╘  ╣╬▌╟▓,,▄      j▐
//     ▌▌    .   «φ╠╢╩«`.-╔▄#░φ¼██╬╩ "╬╗║╠╠║╬▓╬█▓▓▓▄╚╬▒╗╦░╙▀▓▓▌╠▒Å╩╬╣╣▓      j╫
//    .▌▌'    ╓▒╬╝╩│ -,ⁿ╗▓╬╙;╙▀╠╠╬╙ ║╣╦╟▓▓╬╠╬▌╚╬╬╫▓╬ ╠╝╙║╣╩░▐╟██▌ ;╠╬▓▀      ▐╫ ⌐
//    '▌▌           `≈╝▓▓▓εφ▓╬▄▓▓╩ ;╠╬╠j╝[╠╩╬╙▒└╬╠╬▓ ░]║▓▒╣╣╙╙ ▄▄▄╣╝╨        ▐╫  {
// .   ▌▒. '         å▓▀╙▀▄╙,'▐╬▓Γ""[ ╙╠ : ╓╬▒▓▓▒╟▒Γ║▒╠▒▒▒╬╙▄▓▄▄▄╫╬▒╥        ▐╫ ` '
//    '▌▒   -             ▀`  ╨Γ└  ⌐┘ ╫▓ "▓N╝▓▓╣╬▓▓ε╬▌ ⌐╚▀ "▀░╙▒╫▒░║╣⌐       ▐╫
//   ' ▌▒  ░.      '               Γ,▒╣▓▓▓⌐ ╫▓▓╬▓▌ Lⁿ-        ║▌▌░║░╣        ▐╟
//    ]▌▒  .'                      ⁿ└╙╒╬  ≡▄▓╫▓╬▌      \         j╣╜         ▐╫
// ' '"▌⌐~..                         [    ╙M▓▓╬╣       '                     ▐╫
// "` j▒░                            `     ╙╬╠╠╬▌                            ╞╫
//    .▒░,-.                              └"╫█╬╠▓                            ╞╫
//    j▒"░'"'.                              ▄╬▓▓▒▓                           ╞▌
//   .jj. '  ~                                 ╚╝╬╬╦                         │▌
//    ▐▒'                                        `╙╬                         │▌
//  .-▐╣¡                            ~.  ..╓--.   å╠▒,`           Θ=         ╡▌'
// ;~-▐╣.`                          .MG▄æ╩≈"V" ,φ▒φ╠▒▒Å╙Q"ªΣ=,.≡`¬ⁿ«¬        ╡▌
// ~  ▐▐~                     ,.-ⁿ  ╓∩^,-"-^-"╓∩╠▒]▒╠▒▒╚ε`/Ç->,"`≈▒╙Θ--¬     ╠▌
// .  ▐▀                       ¬ⁿε╙╙A¬,"╓∩,~δφ▒φ"╬Γ▐▒╠║Ç╠▒Θ╙▒≥╓"≈`╙WΣ,╖,     ╠▌
//  . j▒"                       !,▒Φ░╩^╚╛^▒╬╠╠╠µ╣▐ ╠╬╠╠╠╠▒╚╠╦▒ç`╦╠╦îJ⌐       ╞▌
// '' j▒                          "'╙░≈╔Θ/3╠╬╠7▒╩▒╠╝╩╠╢d╬╠║╬░╠▒╚"▒╬╙ⁿ        ╞▓
//  ..j▒                            ¬╙▒╠░╙φ▒║▒▐╙░@╠╢╗╬╬╬╬╠▒╠╠δ▒▒╠⌐¬          ╞╫
//     ▒⌐                             `≈"╠▒M╬▒╠╫░#╠╣╠╬╬╚╙φε╘╙░%╝╙╚`          ▐╫
//    "▌                                ┌Γ,δ ╩╠▒╠½╠M▒░│δ└`φε`░               ▐╟
// '   ▌⌐     ,                             '` `' ^⌐╙ ╙¬╜²  '=               ▐╟
//     ▌▄▄Jw-w-w--══╖═══╖≈---------▄▄▄▄▄▄▄▄▄▄▄,,,,,,,,,        (,   ,,,,,,,,,▐╟
//     └╙ ╙                           └ └╙╙╙╙╙╙╙╙╙````````````╙"╙▀``▀``╙`╙`╙ ╙╙  `
//            .
//
// ▄═╗▄m╗╕▓█▌           ═▄▄══▄▀█▌                            ▄▄ÆW▄ j█▌     ▐█▌
// ╙ ╫█▌ └╟█▌Æ█▄ ▄▓▀█µ   ██ ▄└▐█▌ ▄█▀▄,%█▌'██ ¥∩▄█▀▓,▄▓▄▓█  ██─  ╙ ▄▄▌a▄█▄█▐█▌,▄▀%▄
//   ╫█▌  ╟█▌j██▐██▀▀▀   ██¬▀ ▐█▌╟█▌ ██ ██▄╙█▄▌▐██▀▀▀╞█▌    ██⌐╙██▀▐█▌ ██  ▐█▌╙████
//  *╝▀▀⌐ ╝▀▀ª▀▀ ╙▀▀▀└  ═▀▀═  ╝▀▀ ▀▀4▀└  ▀┘ ╚▀  ╙▀▀▀─╧▀▀⌐    ╙▀W╝▀ ╝▀▀∞▀▀═ ╝▀▀╜▀═╝▀
//
// Venusian Flora created by Ryan Meyers @sreyeMnayR for The Flower Girls
// Twitter: @FlowerGirlsNFT  Web: https://flowergirlsnft.com
// 
//
// Generosity attracts generosity.
//
// The world will be saved by beauty.
//
// 
// ERC-1155 Venusian Flora: The First Generation
//

pragma solidity ^0.8.17;

import "./ERC1155_VF.sol";


/**
 * @dev ERC1155 token representing plantable flora for
 *  Venusian Gardens which may be claimed, purchased, 
 *  or airdropped
 */
contract VenusianFloraTheFirstGeneration is ERC1155VF {

    // Claim keys include single-use uint claimIds
    mapping(uint => bool) private _claimed;

    // Flora info in a nice packed struct
    mapping(uint => FloraData) private _flora;

    // Mapping determining the date a given flora was planted by a gardener.
    mapping(address => mapping(uint=>uint)) private _planted;

    // Auto-increment tokenIds when new Flora are created
    uint public nextTokenId = 0;

    constructor(
      string memory uri_,
      string memory name_,
      string memory version_,
      address signer_,
      address bank_,
      address garden_
    )
      ERC1155VF(uri_, name_, version_, signer_, bank_, garden_)
    {}

    /**
     * @dev Creates a new Flora species
     * @param maxSupply The maximum number of this species available (0=Unlimited)
     * @param price If being sold for ETH, the ETH price in wei.
     * @param forSale Boolean indicating whether the Flora may be purchased for ETH
     * @param soulbound Boolean indicating whether a particular Flora is soulbound.
     * @notice A new Flora with tokenId `nextTokenId` will be created.
     */
    function createFlora(
      string calldata uri,
      uint16 maxSupply,      
      uint64 price,    
      bool forSale,    
      bool soulbound
    ) public onlyOwner {
      _flora[nextTokenId] = FloraData(
                              maxSupply,
                              0,
                              0,
                              price,
                              forSale,
                              soulbound,
                              0
                            );
      _setURI(nextTokenId, uri);
      nextTokenId += 1;
    }

    /**
     * @dev Sets the maxSupply of Flora to its current minted number.
     * @param tokenId The tokenId of the Flora to retire
     * @notice The Flora #`tokenId` will be retired.
     */
    function makeFloraUnavailable(
      uint tokenId
    ) public onlyOwner {
      _flora[tokenId].maxSupply = _flora[tokenId].minted;
    }

    /**
     * @dev Sets the price of a Flora
     * @param tokenId The tokenId of the Flora to adjust
     * @param price The new price of the Flora.
     * @notice The Flora #`tokenId` will be set to price `price`.
     */
    function setFloraPrice(
      uint tokenId,
      uint64 price
    ) public onlyOwner {
      FloraData storage flora = _flora[tokenId];
      flora.price = price;
      if (flora.price > 0){
        flora.forSale = true;
      } else {
        flora.forSale = false;
      }
      
    }

    /**
     * @dev Claim a Flora with a signed key. (typically via seed store purchase)
     * @param signature The signed message provided by FGs web interface
     * @param key The struct of data representing the {ClaimKey}
     * @notice The Flora #`key.tokenId` claimed by `key.wallet`.
     */
    function claim(
      bytes calldata signature,
      ClaimKey calldata key
    ) public {
      if (msg.sender != key.wallet) revert WalletNotSender();
      if (!checkClaim(signature, key)) revert InvalidClaimKey();
      if (_claimed[key.claimId]) revert AlreadyClaimed();
      if (_flora[key.tokenId].maxSupply > 0) {
        if (!((_flora[key.tokenId].minted + key.amount) <= _flora[key.tokenId].maxSupply )) revert NotEnoughTokens();
      }
      _mint(msg.sender, key.tokenId, key.amount, bytes(""));
    }

    /**
     * @dev Purchase a Flora for ETH.
     * @param tokenId The tokenId of the Flora being purchased
     * @param amount The number of Flora to purchase
     * @notice `amount` of Flora #`tokenId` will be purchased for ETH.
     */
    function purchase(
      uint tokenId,
      uint amount
    ) public payable {
      if (!_flora[tokenId].forSale) revert NotForSale();
      if (!(msg.value >= (uint256(_flora[tokenId].price) * amount))) revert NotEnoughEth();
      if (_flora[tokenId].maxSupply > 0) {
        if (!((_flora[tokenId].minted + amount) <= _flora[tokenId].maxSupply )) revert NotEnoughTokens();
      }
      _mint(msg.sender, tokenId, amount, bytes(""));
    }

    function _beforeTokenTransfer(
          address operator,
          address from,
          address to,
          uint256[] memory ids,
          uint256[] memory amounts,
          bytes memory data
      ) internal override {
        uint howMany = ids.length;
        for(uint i = 0; i < howMany; i++){

          FloraData storage flora = _flora[ids[i]];

          if (from == address(0)){
            flora.minted+=uint16(amounts[i]);
            flora.supply+=uint16(amounts[i]);
          } else {

            uint planted = _planted[from][ids[i]];
            
            if (to == address(0)){
              // We're burning...
              if (balanceOf(from, ids[i]) == 1) {
                if (uintToBool(planted)) {
                  // If only own one and it's planted, remove it from planted and decrement flora data.
                  emit PlantedFloraBurned(from, ids[i]);
                  delete _planted[from][ids[i]];
                  flora.planted -= 1;
                }
              }
              flora.supply-=uint16(amounts[i]);
            } else {
              /* Can't transfer planted flora */
              if ((balanceOf(from, ids[i]) - uintToZeroOrOne(planted)) < amounts[i]) revert NotEnoughAvailable();
              
              /* Can't transfer soulbound flora */
              if(flora.soulbound) revert CannotTransferSoulbound();
            }
          }
          
        }
        // Call the super method, which importantly includes a call to the Venusian Garden contract (if it exists)
        super._beforeTokenTransfer(operator, to, from, ids, amounts, data);
      }

      /***************************************************************
      * For flora to display in the dynamic Venusian garden, 
      *  it must be planted. Planted flora cannot be transferred.
      *  This is a one-way ticket - the only way to "unplant" is to burn!
      ***************************************************************/

    /**
     * @dev Plant Flora in your Venusian Garden
     * @param tokenId The tokenId of the Flora being planted
     * @notice Flora #`tokenId` will be planted and become soulbound.
     */
      function plantFlora(
        uint256 tokenId
      ) public {
        if ((balanceOf(msg.sender, tokenId) - uintToZeroOrOne(_planted[msg.sender][tokenId])) < 1) revert NotEnoughAvailable();
        _planted[msg.sender][tokenId] = block.timestamp;
        _flora[tokenId].planted += 1;
        emit FloraPlanted(msg.sender, tokenId, block.timestamp);
      }


      /* 
      *  THESE ARE ALL UTILITY FUNCTIONS TO BE 
      *  USED OFF-CHAIN
      *  DO NOT USE ON-CHAIN - it will be hella expensive 
      */

    /**
     * @dev Retrieve a given gardener's planted Flora
     * @param gardener The address of a gardener planting the Flora
     */
      function plantedFloraByGardener(
        address gardener
      ) public view returns(uint[] memory, FloraData[] memory) {
        uint[] memory planted = new uint[](nextTokenId);
        FloraData[] memory plantedFlora = new FloraData[](nextTokenId);
        for(uint i = 0; i < nextTokenId; i++){
          planted[i] = _planted[gardener][i];
          plantedFlora[i] = _flora[i];
        }
        return (planted, plantedFlora);
      }

    /**
     * @dev Retrieve all data for a given Flora
     * @param tokenId The address of a gardener planting the Flora
     */
      function floraData(
        uint tokenId
      ) public view returns(FloraData memory) {
        return _flora[tokenId];
      }

    /**
     * @dev Retrieve data for all Flora
     */
      function floraDataAll() public view returns(FloraData[] memory) {
        FloraData[] memory allFlora = new FloraData[](nextTokenId);
        for(uint i = 0; i < nextTokenId; i++){
          allFlora[i] = _flora[i];
        }
        return allFlora;
      }



}
