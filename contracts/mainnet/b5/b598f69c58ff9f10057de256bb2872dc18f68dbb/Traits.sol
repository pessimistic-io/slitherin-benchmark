// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./Ownable.sol";


contract Traits is Ownable {
    string private constant randomTrait = "?";
    uint256 private constant MAXINT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
    uint256 public mutagenFrequency;

    struct Compatibility {
        string trait;
        string value;
        string variation;
        string baseTrait;
        string baseValue;
        string baseVariation;
        bool compatsEnabled;
        bool compatible;
    }

    struct CompatibilityWithCid {
        string baseTrait;
        string baseValue;
        string baseVariation;
        bool compatsEnabled;
        bool compatible;
        uint256 cid;
    }

    struct Trait {
        string trait;
        string value;
        string variation;
    }

    Compatibility[] internal allCompatibilities;
    mapping(uint256 => CompatibilityWithCid[]) internal compatsMap;
    uint256[] internal seeds;
    uint256[] internal cids;

    uint256 internal _seed;

    mapping(string => bool) traitsExists;
    mapping(string => mapping(string => bool)) valuesExists;
    mapping(string => mapping(string => mapping(string => bool))) variationsExists;

    string[] traits;
    mapping(string => string[]) values;
    mapping(string => mapping(string => string[])) variations;

    uint256[] public hueBg;
    uint256[] public hue;

    mapping(uint256 => mapping(string => string[])) internal constraints;
    mapping(uint256 => bool) internal isCreature;

    constructor(uint256 mutagenFrequency_) {
        _seed = block.timestamp;
        mutagenFrequency = mutagenFrequency_;
    }

    function _requireNotEmpty(string memory arg) internal virtual {
        require(bytes(arg).length > 0, 'T7');
    }

    function _randint(uint256 range) internal virtual returns (uint256) {
        // I have to make it predictable T_T
        // If it depended on block.timestamp or block.difficulty,
        // then we would constantly experience difficulties with
        // correct gas estimation.

        // In fact, true randomness persists in the long run
        // due to the unpredictability of traits generated by DAO.

        _seed = uint256(keccak256(abi.encodePacked(_seed, range)));
        return _seed % range;
    }

    function _randint2(uint256 seed, uint256 seed2) internal pure virtual returns (uint256) {
        return uint256(keccak256(abi.encodePacked(seed, seed2)));
    }

    function equals(string memory a, string memory b) internal pure returns (bool) {
        if(bytes(a).length != bytes(b).length) {
            return false;
        } else {
            return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
        }
    }

    function _genTraits() internal virtual {
        seeds.push(_seed);
        cids.push(allCompatibilities.length);
        hueBg.push(_randint(360));
        hue.push(_randint(360));
    }

    function _checkCompat(string storage trait, string storage value, string storage variation, uint256 cid, Trait[] memory ts, uint256 tsn) internal view virtual returns (bool) {
        for (uint256 ti; ti < tsn; ti++) {
            Trait memory ct = ts[ti];
            bool ce;
            bool cmp;
            uint256 key = uint256(keccak256(abi.encodePacked(trait, value, variation, ct.trait)));
            CompatibilityWithCid[] storage _compats = compatsMap[key];
            for (uint256 ci; ci < _compats.length; ci++) {
                CompatibilityWithCid storage c = _compats[ci];
                if (c.cid >= cid) {
                    break;
                }
                ce = c.compatsEnabled;
                if (equals(ct.value, c.baseValue) && equals(ct.variation, c.baseVariation)) {
                    cmp = c.compatible;
                }
            }
            if (ce && !cmp) {
                return false;
            }
        }
        return true;
    }

    function _getTrait(string[] storage allowedVals, string storage trait, uint256 tn, uint256 cid, Trait[] memory ts, uint256 tsn) internal view virtual returns (uint256, string storage, string storage) {
        uint256 j;
        uint256 k;
        uint256 n;
        string[] storage vals = allowedVals.length > 0 ? allowedVals : values[trait];
        for (; j < vals.length; j++) {
            string storage value = vals[j];
            for (k = 0; k < variations[trait][value].length; k++) {
                string storage variation = variations[trait][value][k];
                if (_checkCompat(trait, value, variation, cid, ts, tsn)) {
                    if (tn == n) {
                        return (n, value, variation);
                    }
                    n++;
                }
            }
        }
        return (n, trait, trait);
    }

    function _ensureVariation(
        string storage trait,
        string storage value,
        string storage variation
    ) internal virtual {
        if (bytes(trait).length == 0 || bytes(value).length == 0 || bytes(variation).length == 0) {
            return;
        }

        if (!traitsExists[trait]) {
            traitsExists[trait] = true;
            traits.push(trait);
        }

        if (!valuesExists[trait][value]) {
            valuesExists[trait][value] = true;
            values[trait].push(value);
        }

        if (!variationsExists[trait][value][variation]) {
            variationsExists[trait][value][variation] = true;
            variations[trait][value].push(variation);
        }
    }

    function _mutate(uint256 idx1, uint256 idx2) internal virtual {
        Trait[] memory traits1 = getTraits(idx1);
        Trait[] memory traits2 = getTraits(idx2);

        require(traits1.length + traits2.length > 2, "T5");

        uint256 _s = seeds[seeds.length - 1];
        uint256 _c = cids[cids.length - 1];
        uint256 _h = hue[hue.length - 1];
        uint256 _hb = hueBg[hueBg.length - 1];

        seeds.pop();
        cids.pop();
        hue.pop();
        hueBg.pop();

        _genTraits();

        uint256 idx = seeds.length - 1;
        uint256 i;

        for (i = 0; i < traits1.length; i++) {
            constraints[idx][traits1[i].trait].push(traits1[i].value);
        }
        for (i = 0; i < traits2.length; i++) {
            constraints[idx][traits2[i].trait].push(traits2[i].value);
        }
        for (i = 0; i < traits.length; i++) {
            string[] storage vals = constraints[idx][traits[i]];
            if (vals.length > 0 && (bytes(vals[0]).length == 0 || (vals.length == 2 && bytes(vals[1]).length == 0))) {
                delete constraints[idx][traits[i]];
            }
        }

        isCreature[idx] = true;

        seeds.push(_s);
        cids.push(_c);
        hue.push(_h);
        hueBg.push(_hb);
    }

    function getTraits(uint256 idx) public view virtual returns (Trait[] memory) {
        uint256 seed = seeds[idx];

        if (!isCreature[idx] && (seed % mutagenFrequency == 0)) {
            Trait[] memory _ts = new Trait[](1);
            seed = _randint2(seed, idx);
            _ts[0].trait = traits[seed % traits.length];
            return _ts;
        }

        Trait[] memory ts = new Trait[](traits.length);
        uint256 tsn = 0;

        uint256 cid = cids[idx];
        uint256 i;
        uint256 tn;
        string storage value;
        string storage variation;

        for (; i < traits.length; i++) {
            string storage trait = traits[i];
            string[] storage allowedVals = constraints[idx][trait];
            (tn, value, variation) = _getTrait(allowedVals, trait, MAXINT, cid, ts, tsn);
            if (tn == 0) {
                continue;
            }
            seed = _randint2(seed, tn);
            (tn, value, variation) = _getTrait(allowedVals, trait, seed % tn, cid, ts, tsn);
            ts[tsn].trait = trait;
            ts[tsn].value = value;
            ts[tsn].variation = variation;
            tsn++;
        }

        Trait[] memory retTraits = new Trait[](tsn);
        for (i = 0; i < tsn; i++) {
            retTraits[i] = ts[i];
        }
        return retTraits;
    }

    function getCompats() external view virtual returns (Compatibility[] memory) {
        return allCompatibilities;
    }
}
