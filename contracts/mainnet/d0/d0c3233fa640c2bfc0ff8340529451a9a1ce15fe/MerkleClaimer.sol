// SPDX-License-Identifier: MIT
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@              @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                           @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
/**
 * @dev: @brougkr
 */
pragma solidity 0.8.17;
import {Ownable} from "./Ownable.sol";
import {IERC721} from "./IERC721.sol";
import {IERC20} from "./IERC20.sol";
import {MerkleProof} from "./MerkleProof.sol";
import {ReentrancyGuard} from "./ReentrancyGuard.sol";
import {IMinter} from "./IMinter.sol";
import {IMP} from "./IMP.sol";
contract MerkleClaimer is Ownable, ReentrancyGuard
{
    /*-------------------*/
    /*      STRUCT       */
    /*-------------------*/

    struct User
    {
        bool[] RegularClaim;
        uint _UserPurchasedAmount;
    }

    struct Claim
    {
        string _Name;
        address _NFT; 
        address _Operator; 
        address _BurnNFT; 
        uint _ClaimCost; 
        uint _ProjectID; 
        uint _ClaimableAmount; 
        uint _AmountClaimed; 
        bytes32 _Root; 
    }

    address private constant _BURN_ADDRESS = 0xcff43A597911a9457071d89d2b2AC3D5b1862b86;

    /*-------------------*/
    /*     MAPPINGS      */
    /*-------------------*/

    mapping(uint=>Claim) public Claims;                               // [ClaimIndex] => Claim
    mapping(uint=>mapping(uint=>bool)) public ClaimedTokenID;         // [ClaimIndex][TokenID] => Minted
    mapping(uint=>mapping(address=>uint)) public UserPurchasedAmount; // [ClaimIndex][Wallet] => Total Purchased Amount
    
    /*-------------------*/
    /*      EVENTS       */
    /*-------------------*/

    event TokensClaimed(address Redeemer, uint[] TokenIDs);
    event TokensClaimedAndBurned(address Redeemer, uint[] ClaimTokenIDs, uint[] BurnTokenIDs);
    event TokensClaimedPurchaseTo(address Redeemer, uint ProjectID, uint Amount);

    /*-------------------*/
    /*    CONSTRUCTOR    */
    /*-------------------*/

    constructor() 
    { 
        Claims[0] = Claim( 
            'GTMX | Citizen',                           // [0] -> _Name
            0xa7923530DE01B7019688a6CB0ff5f5388185200f, // [1] -> _NFT
            0x93F01412C062C99C6ef105b1BAd93800B5635479, // [2] -> _Operator
            0x7581e6E514bac22B6303e92A5eAa4bfF3167142D, // [3] -> _BurnNFT
            0,                                          // [4] -> _ClaimCost
            0,                                          // [5] -> _ProjectID
            10,                                         // [6] -> _ClaimableAmount
            0,                                          // [7] -> _AmountClaimed
            0x80ed4a6987e367e9b9a580b9eea7c9f4459c5e64f69b43d72adc3ef29e519ef5 // [8] -> _Root
        );
        Claims[1] = Claim(
            'Spongenuity',                              // [0] -> _Name               
            0x7c3Ea2b7B3beFA1115aB51c09F0C9f245C500B18, // [1] -> _NFT
            0x5A9C8Ab74D4d42525Be6501140C4c77006fa0c18, // [2] -> _Operator
            address(0),                                 // [3] -> _BurnNFT
            0,                                          // [4] -> _ClaimCost
            0,                                          // [5] -> _ProjectID
            100,                                        // [6] -> _ClaimableAmount
            0,                                          // [7] -> _AmountClaimed
            0x68fe703ee98cc44d2f815e888819208a2bbeb34c7a2d91e12300e941a18abed1 // [8] -> _Root
        );
        Claims[2] = Claim( 
            'MPTK Option | MPTK',
            0xA636d716024fAf7Db5876DD817859984f00E7AEF, // [0] -> _NFT
            0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700, // [1] -> _Operator
            0x140D6adB981c8a0781326214f3c8154D2F01b6ac, // [2] -> _BurnNFT
            211959783913565000,                         // [3] -> _ClaimCost
            0,                                          // [4] -> _ProjectID
            100,                                        // [5] -> _ClaimableAmount
            0,                                          // [6] -> _AmountClaimed
            0x48e6e23fbb3ea90262d6bf2f7f1b61dabd86311a46e7456a6ac35e142a97a0b3 // [8] -> _Root
        );
        _transferOwnership(0xe06F5FAE754e81Bc050215fF89B03d9e9FF20700); // `operator.brightmoments.eth`
    } 

    /*----------------------*/
    /*  EXTERNAL FUNCTIONS  */
    /*----------------------*/

    /**
     * @dev Claims TokenID(s) With Merkle
     * note: transferFrom Implementation For NFT Transfer
     */
    function MerkleClaim (
        uint ClaimIndex,
        uint[] calldata TokenIDs,
        bytes32[][] calldata Proof 
    ) external payable nonReentrant {
        require(msg.value == (Claims[ClaimIndex]._ClaimCost * TokenIDs.length), "Claimer: Invalid Message Value Sent");
        require(Proof.length > 0 && TokenIDs.length > 0, "Claimer: Invalid Input");
        require(Proof.length == TokenIDs.length, "Claimer: Arrays Must Match");
        bool[] memory Eligibles = ReadEligibilityMerkleClaim(ClaimIndex, msg.sender, TokenIDs, Proof);
        for(uint Index; Index < TokenIDs.length; Index++)
        {
            require(Eligibles[Index], "Claimer: Invalid Merkle");
            require(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]], "Claimer: NFT TokenID Already Claimed");
            ClaimedTokenID[ClaimIndex][TokenIDs[Index]] = true;
            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, TokenIDs[Index]);
        }
        emit TokensClaimed(msg.sender, TokenIDs);
    }

    /**
     * @dev Claims TokenID(s) With Merkle
     * note: purchaseTo Implementation For NFT Transfer
     */
    function MerkleClaimPurchaseTo (
        uint ClaimIndex,
        uint DesiredAmount,
        uint MaxAmount,
        bytes32[] calldata Proof 
    ) external payable nonReentrant {
        require(ReadEligibilityMerkleAmount(ClaimIndex, msg.sender, MaxAmount, Proof), "Claimer: Invalid Merkle");
        require(msg.value == (Claims[ClaimIndex]._ClaimCost * DesiredAmount), "Claimer: Invalid Message Value Sent");
        require(DesiredAmount > 0 && UserPurchasedAmount[ClaimIndex][msg.sender] + DesiredAmount <= MaxAmount, "Claimer: Invalid DesiredAmount");
        require(Claims[ClaimIndex]._ClaimableAmount >= Claims[ClaimIndex]._AmountClaimed + DesiredAmount, "Claimer: Too Many");
        UserPurchasedAmount[ClaimIndex][msg.sender] += DesiredAmount;
        Claims[ClaimIndex]._AmountClaimed += DesiredAmount;
        for(uint Index; Index < DesiredAmount; Index++) { IMinter(Claims[ClaimIndex]._NFT).purchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID); }
        emit TokensClaimedPurchaseTo(msg.sender, Claims[ClaimIndex]._ProjectID, DesiredAmount);
    }

    /**
     * @dev Claims TokenID(s) With Merkle
     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)
     * note: transferFrom Implementation For NFT Burn & Transfer
     */
    function MerkleClaimAndBurn (
        uint ClaimIndex,
        uint[] calldata BurnTokenIDs,
        uint[] calldata ClaimTokenIDs,
        bytes32[][] calldata Proof 
    ) external payable nonReentrant {
        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), "Claimer: Invalid Message Value Sent");
        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, "Claimer: Invalid Input");
        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, "Claimer: Arrays Must Match");
        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);
        for(uint Index; Index < BurnTokenIDs.length; Index++)
        {
            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, "Claimer: User Does Not Own Input TokenID");
            IERC721(Claims[ClaimIndex]._BurnNFT).transferFrom(msg.sender, _BURN_ADDRESS, BurnTokenIDs[Index]);
            require(Eligibles[Index], "Claimer: Invalid Merkle");
            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], "Claimer: NFT Already Claimed");
            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;
            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);
        }
        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);
    }

    /**
     * @dev Claims TokenID(s) With Merkle
     * note: This Is For 1:1 Mapping Burn To Redeem. Ex. Burn (NFT A TokenID 1) for (NFT B TokenID 90069420)
     * note: transferFrom Implementation For NFT Burn & Transfer
     */
    function MerkleClaimAndBurnLive (
        uint ClaimIndex,
        uint[] calldata BurnTokenIDs,
        uint[] calldata ClaimTokenIDs,
        bytes32[][] calldata Proof 
    ) external payable nonReentrant {
        require(msg.value == (Claims[ClaimIndex]._ClaimCost * ClaimTokenIDs.length), "Claimer: Invalid Message Value Sent");
        require(Proof.length > 0 && BurnTokenIDs.length > 0 && ClaimTokenIDs.length > 0, "Claimer: Invalid Input");
        require(BurnTokenIDs.length == ClaimTokenIDs.length && ClaimTokenIDs.length == Proof.length, "Claimer: Arrays Must Match");
        bool[] memory Eligibles = ReadEligibilityMerkleClaimAndBurn(ClaimIndex, BurnTokenIDs, ClaimTokenIDs, Proof);
        for(uint Index; Index < BurnTokenIDs.length; Index++)
        {
            require(IERC721(Claims[ClaimIndex]._BurnNFT).ownerOf(BurnTokenIDs[Index]) == msg.sender, "Claimer: User Does Not Own Input TokenID");
            require(Eligibles[Index], "Claimer: Invalid Merkle");
            IMP(Claims[ClaimIndex]._BurnNFT)._LiveMintBurn(BurnTokenIDs[Index]);
            require(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]], "Claimer: NFT Already Claimed");
            ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]] = true;
            IERC721(Claims[ClaimIndex]._NFT).transferFrom(Claims[ClaimIndex]._Operator, msg.sender, ClaimTokenIDs[Index]);
        }
        emit TokensClaimedAndBurned(msg.sender, ClaimTokenIDs, BurnTokenIDs);
    }

    /*-------------------*/
    /*  OWNER FUNCTIONS  */
    /*-------------------*/

    /**
     * @dev Approves ERC20 Address For Claim
     */
    function __ApproveERC20(uint ClaimIndex, address ERC20) external onlyOwner 
    { 
        IERC20(ERC20).approve(Claims[ClaimIndex]._NFT, type(uint).max); 
    }

    /**
     * @dev Starts A New Claim
     */
    function __NewClaim(
        uint ClaimIndex,
        string calldata Name,
        address NFT,
        address Operator,
        address BurnNFT,
        uint ClaimCost,
        uint ProjectID,
        uint PurchaseableAmount,
        bytes32 Root
    ) external onlyOwner {
        Claims[ClaimIndex] = Claim(
            Name,
            NFT,
            Operator,
            BurnNFT,
            ClaimCost,
            ProjectID,
            PurchaseableAmount,
            0,
            Root
        );
    }

    /**
     * @dev Changes NFT
     */
    function __ChangeNFT(uint ClaimIndex, address NFT) external onlyOwner { Claims[ClaimIndex]._NFT = NFT; }

    /**
     * @dev Changes Operator
     */
    function __ChangeOperator(uint ClaimIndex, address Operator) external onlyOwner { Claims[ClaimIndex]._Operator = Operator; }

    /**
     * @dev Changes BurnNFT
     */
    function __ChangeBurnNFT(uint ClaimIndex, address BurnNFT) external onlyOwner { Claims[ClaimIndex]._BurnNFT = BurnNFT; }

    /**
     * @dev Changes ClaimCost
     */
    function __ChangeClaimCost(uint ClaimIndex, uint ClaimCost) external onlyOwner { Claims[ClaimIndex]._ClaimCost = ClaimCost; }

    /**
     * @dev Changes ProjectID
     */
    function __ChangeProjectID(uint ClaimIndex, uint ProjectID) external onlyOwner { Claims[ClaimIndex]._ProjectID = ProjectID; }
    
    /**
     * @dev Changes PurchaseableAmount
     */
    function __ChangePurchaseableAmount(uint ClaimIndex, uint PurchaseableAmount) external onlyOwner { Claims[ClaimIndex]._ClaimableAmount = PurchaseableAmount; }

    /**
     * @dev Changes Root
     */
    function __ChangeRoot(uint ClaimIndex, bytes32 Root) external onlyOwner { Claims[ClaimIndex]._Root = Root; }

    /**
     * @dev Withdraws All Ether From The Contract
     */
    function ___WithdrawEther() external onlyOwner { payable(msg.sender).transfer(address(this).balance); }

    /**
     * @dev Withdraws Ether From Contract To Address With An Amount
     */
    function ___WithdrawEtherToAddress(address payable Recipient, uint Amount) external onlyOwner
    {
        require(Amount > 0 && Amount <= address(this).balance, "Claimer: Invalid Amount");
        (bool Success, ) = Recipient.call{value: Amount}("");
        require(Success, "Claimer: Unable to Withdraw, Recipient May Have Reverted");
    }

    /*------------------*/
    /*  VIEW FUNCTIONS  */
    /*------------------*/

    /**
     * @dev Returns A Wallet's Merkle Eligibility
     */
    function ReadEligibilityMerkleClaim (
        uint ClaimIndex,
        address Wallet,
        uint[] calldata TokenIDs,
        bytes32[][] calldata Proof
    ) public view returns (bool[] memory) {
        bool[] memory Eligibles = new bool[](TokenIDs.length);
        for(uint Index; Index < TokenIDs.length; Index++)
        {
            bytes32 Leaf = keccak256(abi.encodePacked(Wallet, TokenIDs[Index]));
            if(!ClaimedTokenID[ClaimIndex][TokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }
        }
        return Eligibles;
    }

    /**
     * @dev Returns A Wallet's Merkle Eligibility
     */
    function ReadEligibilityMerkleClaimAndBurn (
        uint ClaimIndex,
        uint[] calldata BurnTokenIDs, 
        uint[] calldata ClaimTokenIDs,
        bytes32[][] calldata Proof
    ) public view returns (bool[] memory) {
        bool[] memory Eligibles = new bool[](BurnTokenIDs.length);
        for(uint Index; Index < BurnTokenIDs.length; Index++)
        {
            bytes32 Leaf = keccak256(abi.encodePacked(BurnTokenIDs[Index], ClaimTokenIDs[Index]));
            if(!ClaimedTokenID[ClaimIndex][ClaimTokenIDs[Index]]) { Eligibles[Index] = MerkleProof.verify(Proof[Index], Claims[ClaimIndex]._Root, Leaf); }
        }
        return Eligibles;
    }

    /**
     * @dev Returns A Wallet's Merkle Eligibility
     * note: For Claims Where There Is A Derived Max Amount Per Wallet
     */
    function ReadEligibilityMerkleAmount (
        uint ClaimIndex,
        address Wallet,
        uint MaxAmount,
        bytes32[] calldata Proof
    ) public view returns (bool) {
        bytes32 Leaf = keccak256(abi.encodePacked(Wallet, MaxAmount));
        return MerkleProof.verify(Proof, Claims[ClaimIndex]._Root, Leaf);
    }

    /**
     * @dev Returns Merkle Eligibilities
     */
    function ReadEligibility (
        uint ClaimIndex,
        address Wallet,
        uint[] calldata TokenIDs,
        bytes32[][] calldata Proofs
    ) public view returns (User memory) {
        return User (
            ReadEligibilityMerkleClaim(ClaimIndex, Wallet, TokenIDs, Proofs),
            UserPurchasedAmount[ClaimIndex][Wallet]
        );
    }
}
